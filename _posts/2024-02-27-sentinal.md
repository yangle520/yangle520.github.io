---
layout: post
title:  Sentinal
date:   2024-02-27 00:00:00 +0800
categories: 微服务
tag: 微服务组件
---



* content
{:toc}




## Sentinal

Sentinel 是面向分布式服务架构的高可用微服务防护组件

### 介绍

Sentinel 是面向分布式、多语言异构化服务架构的流量治理组件，主要以流量为切入点，从流量路由、流量控制、流量整形、熔断降级、系统自适应过载保护、热点流量防护等多个维度来帮助开发者保障微服务的稳定性。

#### 基本概念

##### 资源

只要通过sentinel API定义的代码，就是资源。能被sentinel保护起来

可以使用方法签名，URL，甚至服务名作为资源名来标示资源

##### 规则

围绕资源的实时状态设定的规则，可以包括流量控制规则、熔断降级规则以及系统保护规则。所有规则可以动态实时调整。

#### 特性

1. 适用场景丰富
2. 提供实时监控的功能，包括查看单机秒级数据，设置500台以下规模的集群汇总运行情况
3. 只需引入Maven依赖并进行简单的配置，即可快速与Spring cloud、dubbo、gRPC等进行整合



### 功能和设计理念

#### 流量控制

流量控制在网络传输中是一个常用的概念，它用于调整网络包的发送数据。然而，从系统稳定性角度考虑，在处理请求的速度上，也有非常多的讲究。任意时间到来的请求往往是随机不可控的，而系统的处理能力是有限的。我们需要根据系统的处理能力对流量进行控制。Sentinel 作为一个调配器，可以根据需要把随机的请求调整成合适的形状

![sentinel主要特性]({{ '/styles/images/sentinal/sentinel-flow-overview.jpg' | prepend: site.baseurl  }})

提前对各个类型的请求设置最高的QPS阈值，若高于设置的阈值则对该请求直接返回，不再调用后续资源。Sentinel提供了两种流量统计方式，一种是统计并发线程数，另外一种则是统计 QPS，当并发线程数超出某个设定的阀值，新的请求会被立即拒绝，当QPS超出某个设定的阀值，系统可以通过直接拒绝、冷启动、匀速器三种方式来应对，从而起流量控制的作用



##### 熔断降级

如果某个目标服务调用慢或者有大量超时，此时熔断该服务的调用，对于后续调用请求，不在继续调用目标服务，直接返回，快速释放资源。熔断一般需要设置不同的恢复策略，如果目标服务情况好转则恢复调用。服务之间会有相互依赖关系，例如服务A做到了1秒上万个QPS，但这时候服务B并无法满足1秒上万个QPS，那么如何保证服务A在高频调用服务B时，服务B仍能正常工作呢？一种比较常见的情况是，服务A调用服务B时，服务B因无法满足高频调用出现响应时间过长的情况，导致服务A也出现响应过长的情况，进而产生连锁反应影响整个依赖链上的所有应用，这时候就需要熔断和降级的方法。Sentinel通过并发线程数进行限制和响应时间对资源进行降级两种手段来对服务进行熔断或降级。

##### 塑形

通常我们遇到的流量具有随机性、不规则、不受控的特点，但系统的处理能力往往是有限的，我们需要根据系统的处理能力对流量进行塑形，即规则化，从而根据我们的需要来处理流量

#### 主要特性

![sentinel主要特性]({{ '/styles/images/sentinal/sentinel-features-overview-en.png' | prepend: site.baseurl  }})



### 快速开始

Sentinel 的使用可以分为两个部分:

1. 核心库（Java 客户端）：不依赖任何框架/库，能够运行于 Java 8 及以上的版本的运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持
2. 控制台（Dashboard）：Dashboard 主要负责管理推送规则、监控、管理机器信息等

#### 1、引入依赖

在 pom.xml 中加入依赖

```xml
<dependency>
	<groupId>com.alibaba.cloud</groupId>
	<artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
	<version>2.1.1.RELEASE</version>
</dependency>
```

#### 2、定义资源

通过Sentinel API将代码块定义成资源

使用 `SphU.entry("HelloWorld")` 和 `entry.exit()` 包围起来即可

```java
public static void main(String[] args) {
    // 配置规则.
    initFlowRules();

    while (true) {
        // 1.5.0 版本开始可以直接利用 try-with-resources 特性
        try (Entry entry = SphU.entry("HelloWorld")) {
            // 被保护的逻辑
            System.out.println("hello world");
		} catch (BlockException ex) {
            // 处理被流控的逻辑
	    	System.out.println("blocked!");
		}
    }
}
```

通过注解将一个方法定义成资源

```java
@SentinelResource("HelloWorld")
public void helloWorld() {
	// 资源中的逻辑*    
	System.out.println("hello world"); 
}
```



#### 3、定义规则

限制资源的访问规则

例如下面的代码定义了资源 `HelloWorld` 每秒最多只能通过 20 个请求

```java
private static void initFlowRules(){
    List<FlowRule> rules = new ArrayList<>();
    FlowRule rule = new FlowRule();
    rule.setResource("HelloWorld");
    rule.setGrade(RuleConstant.FLOW_GRADE_QPS);
    // Set limit QPS to 20.
    rule.setCount(20);
    rules.add(rule);
    FlowRuleManager.loadRules(rules);
}
```

完成这3步，sentinel就能够正常工作了

#### 4、检查效果

运行后可以在日志里面看到输出



其中 `p` 代表通过的请求, `block` 代表被阻止的请求, `s` 代表成功执行完成的请求个数, `e` 代表用户自定义的异常, `rt` 代表平均响应时长。

#### 5、启动控制台

Sentinel 开源控制台支持实时监控和规则管理

**启动命令**

java -Dserver.port=8000 -Dcsp.sentinel.dashboard.server=localhost:8000 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard-1.8.7.jar

访问控制台：http://localhost:8000
用户名：sentinel
密码：sentinel



客户端需要引入 Transport 模块来与 Sentinel 控制台进行通信。您可以通过 `pom.xml` 引入 JAR 包

```xml
<dependency>    
	<groupId>com.alibaba.csp</groupId>    
    <artifactId>sentinel-transport-simple-http</artifactId>
    <version>1.8.6</version> 
</dependency>
```

启动时加入 JVM 参数 `-Dcsp.sentinel.dashboard.server=consoleIp:port` 指定控制台地址和端口



### 配置选项

Spring Cloud Alibaba Sentinel 提供了这些配置选项:

| 配置项                                                  | 含义                                                         | 默认值            |
| ------------------------------------------------------- | ------------------------------------------------------------ | ----------------- |
| `spring.application.name` or `project.name`             | Sentinel项目名                                               |                   |
| `spring.cloud.sentinel.enabled`                         | Sentinel自动化配置是否生效                                   | true              |
| `spring.cloud.sentinel.eager`                           | 是否提前触发 Sentinel 初始化                                 | false             |
| `spring.cloud.sentinel.transport.port`                  | 应用与Sentinel控制台交互的端口，应用本地会起一个该端口占用的HttpServer | 8719              |
| `spring.cloud.sentinel.transport.dashboard`             | Sentinel 控制台地址                                          |                   |
| `spring.cloud.sentinel.transport.heartbeat-interval-ms` | 应用与Sentinel控制台的心跳间隔时间                           |                   |
| `spring.cloud.sentinel.transport.client-ip`             | 此配置的客户端IP将被注册到 Sentinel Server 端                |                   |
| `spring.cloud.sentinel.filter.order`                    | Servlet Filter的加载顺序。Starter内部会构造这个filter        | Integer.MIN_VALUE |
| `spring.cloud.sentinel.filter.url-patterns`             | 数据类型是数组。表示Servlet Filter的url pattern集合          | /*                |
| `spring.cloud.sentinel.filter.enabled`                  | Enable to instance CommonFilter                              | true              |
| `spring.cloud.sentinel.metric.charset`                  | metric文件字符集                                             | UTF-8             |
| `spring.cloud.sentinel.metric.file-single-size`         | Sentinel metric 单个文件的大小                               |                   |
| `spring.cloud.sentinel.metric.file-total-count`         | Sentinel metric 总文件数量                                   |                   |
| `spring.cloud.sentinel.log.dir`                         | Sentinel 日志文件所在的目录                                  |                   |
| `spring.cloud.sentinel.log.switch-pid`                  | Sentinel 日志文件名是否需要带上 pid                          | false             |
| `spring.cloud.sentinel.servlet.block-page`              | 自定义的跳转 URL，当请求被限流时会自动跳转至设定好的 URL     |                   |
| `spring.cloud.sentinel.flow.cold-factor`                | WarmUp 模式中的 冷启动因子                                   | 3                 |
| `spring.cloud.sentinel.zuul.order.pre`                  | SentinelZuulPreFilter 的 order                               | 10000             |
| `spring.cloud.sentinel.zuul.order.post`                 | SentinelZuulPostFilter 的 order                              | 1000              |
| `spring.cloud.sentinel.zuul.order.error`                | SentinelZuulErrorFilter 的 order                             | -1                |
| `spring.cloud.sentinel.scg.fallback.mode`               | Spring Cloud Gateway 流控处理逻辑 (选择 `redirect` or `response`) |                   |
| `spring.cloud.sentinel.scg.fallback.redirect`           | Spring Cloud Gateway 响应模式为 'redirect' 模式对应的重定向 URL |                   |
| `spring.cloud.sentinel.scg.fallback.response-body`      | Spring Cloud Gateway 响应模式为 'response' 模式对应的响应内容 |                   |
| `spring.cloud.sentinel.scg.fallback.response-status`    | Spring Cloud Gateway 响应模式为 'response' 模式对应的响应码  | 429               |
| `spring.cloud.sentinel.scg.fallback.content-type`       | Spring Cloud Gateway 响应模式为 'response' 模式对应的 content-type | application/json  |



## 参考资料

源码：https://github.com/alibaba/Sentinel

中文文档：https://sentinelguard.io/zh-cn/docs/introduction.html