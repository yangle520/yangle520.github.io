---
layout: post
title: 系统架构设计师教程 - 5 - 软件工程
subtitle: 软件工程
date:   2023-01-05 00:00:00
categories: 软考 系统架构设计师教程
tag: 软考
author: YangLe
---







## 一、软件工程

### 1、定义

**软件工程**一直以来都缺乏一个统一的定义，很多学者和组织机构都分别给出了自己的定义：

- Barry Boehm：运用现代科学技术知识来设计并构造计算机程序 及 为开发、运行、维护 这些程序所必须的相关文件资料
- IEEE：软件工程是：①将系统化的、严格约束的、可量化的 方法应用于软件的开发、运行、维护，即将工程化应用于软件；② 对①中所述方法的研究
- Fritz Bauer：建立并使用完善的工程化原则，以较经济的手段获得能在实际机器上有效运行的可靠软件的一系列方法
- 《计算机科学技术百科全书》：软件工程是应用计算机科学、数学、逻辑学、管理科学 等原理，开发软件的工程。软件工程借鉴传统工程的原则和方法，以提高质量、降低成本 和 改进算法。其中
  - 计算机科学、数学用于构建模型与算法；
  - 工程科学用于制定规范、设计范型、评估成本、确定权衡
  - 管理科学用于 计划、资源、质量、成本 等管理

**软件工程过程** 是指为了获得软件产品，在软件工具的支持下由软件工程师完成的一系列软件工程活动，包括以下 4 个方面：

1. P（Plan）：软件规格说明。规定软件的功能及其运行时的限制
2. D（Do）：软件开发。开发出满足规格说明的软件
3. C（Check）：软件确认。确认开发的软件能够满足用户的需求
4. A（Action）：软件演讲。软件在运行过程中不断改进以满足客户新的需求



### 2、软件过程模型

软件要经历从需求分析、软件设计、软件开发、运行维护，直至被淘汰这样的全过程，这个全过程称为**软件的生命周期**。

为了使软件生命周期中的各项任务能够有序地按照规程进行，需要一定地工作模型对各项任务给予规程约束，这样地工作模型被称为软件过程模型，有时也称之为**软件生命周期模型**。



#### 2.1 瀑布模型

**瀑布模型**：

> 需求分析 -> 系统设计 -> 程序设计 -> 编码实现 -> 单元测试 -> 集成测试 -> 系统测试 -> 运行维护

**瀑布模型的特点** 是因果关系紧密相连，前一个阶段工作地输出结果，是后一个阶段工作地输入。每一个阶段都是建筑在前一个阶段正确实施的结果之上。每一个阶段工作完成后都伴随着一个里程碑（一组检查条件），对该阶段的工作进行审查和确认。

**瀑布模型的重要作用**：它的出现有利于人员的组织管理，有利于软件开发方法和工具的研究。

**瀑布模型的缺的**：

1. 软件需求的完整性、正确性等很难确定，甚至是不可能和不现实的。
2. 瀑布模型是一个严格串行化的过程模型，使得用户和软件项目负责人要相当长的时间才能得到一个可以看见的软件系统。如果出现与用户的期望不一致，或者出现需求变更，将会带来巨大的损失。
3. 瀑布模型的基本原则是在每个阶段一次性地完全解决该阶段地工作，不会出现遗漏、错误等情况，而实际上这是不现实或不可能地



#### 2.2 原型化模型

原型模型（Prototype Model）又称快速原型。由于普通模型地缺的，人们借鉴建筑师、工程师建造原型地经验，提出了原型模型。

![图片]({{ '/images/ruankao/framework/5/原型模型.png' | prepend: site.baseurl }})

原型模型主要有以下两个阶段：

1. **原型开发阶段**：软件开发人员根据用户提出地软件系统的定义，快速地开发一个原型。该原型应该包含目标系统地关键问题和反应目标系统地大致面貌，展示目标系统地全部或部分功能、性能等。开发原型可以考虑以下途径：
   - 利用模拟软件系统的人机界面和人机交互方式
   - 真正开发一个原型
   - 找来一个或几个正在运行的类似软件进行比较
2. **目标软件开发阶段**：在征求用户对原型的意见后 对原型进行修改完善，确认软件系统的需求并达到一致的理解，进一步开发实际系统。原型模型的使用应该注意以下内容：
   - 用户对系统的认识模糊不清，无法准确回答目标系统的需求
   - 要有一定的开发环境和工具支持
   - 经过对原型的若干次修改，应收敛到目标范围内，否则可能会失败
   - 对大型软件来说，原型可能会非常复杂而难以快速形成，如果没有现成的原型模型，就不应考虑用原型法



#### 2.3 螺旋模型

螺旋模型（Spiral Model）是在快速原型的基础上扩展而成。

![图片]({{ '/images/ruankao/framework/5/螺旋模型.png' | prepend: site.baseurl }})

螺旋模型把整个软件开发流程分成多个阶段，每一个阶段都由4部分组成：

1. **目标设定**：为该项目进行需求分析，定义和确定这一个阶段的专门目标，指定对过程和产品的约束，并且制定详细的管理计划
2. **风险分析**：对可选方案进行风险识别和详细分析，制定解决办法，采取有效措施避免这些风险
3. **开发和有效性验证**：风险评估后，可以为系统选择开发模型，并且进行原型开发，即开发软件产品
4. **评审**：对项目进行评审，以确定是否需要进入螺旋线的下一次回路，如果决定继续，就要制定下一阶段计划。

螺旋模型的软件开发过程实际是上述4个部分的迭代过程，每迭代依次，螺旋线就增加一圈，软件系统就生成一个新版本，这个新版本实际上是对目标系统的一个逼近。经过若干次的迭代后，系统应该尽快地收敛到用户允许或可以接受的目标范围内，否则也有可能中途夭折。

该模型支持大型软件开发，适用于 面向规格说明、面向过程、面向对象 的软件开发方法，也适用于几种开发方法的组合。



### 3 敏捷模型

软件开发在20世纪90年代受到两个大的因素影响：

- 对内，面向对象编程 开始取代 面向过程编程
- 对外，互联网泡沫导致 快速投向市场 以及 公司的快速发展 成为关键商业因素。



#### 3.1 敏捷方法的特点

敏捷型方法是 **适应性**（adaptive）而非预设性（predicative）。敏捷的目的就是称为适应变化的过程，甚至能允许改变自身来适应变化。

敏捷型方法是 **面向人的**（People-oriented）而非 面向过程的（Process-oriented）。它们试图使软件开发工作能够充分发挥的创造能力。它们强调软件开发应当是一项愉快的活动。

##### 3.1.1 适应性和预设性

软件的设计之所以难以实现，问题在于软件需求的不稳定，从而导致软件过程的不可预测。但是传统的控制项目的模式都是针对可预测的环境，在不可预测的环境下，往往无法使用这些方法。

但是，必须对这样的过程进行监控，以使得整个过程能向期望的目标前进。于是 Agile 方法引入 **适应性** 方法，该方法使用反馈机制对不可预测过程进行控制。

##### 3.1.2 面向人而非面向过程

**传统计划驱动方法**的目标之一是使得一个项目的参与人员成为可替代的部件。这样的一种过程将人看成一种资源，他们具有不同的角色，如分析员、程序员、测试员、管理人员。个体是不重要的，只有角色才是重要的。这样考虑的一个重要的出发点就是：尽量减少人为因素对开发过程的影响。但是，敏捷型方法则正好相反。计划驱动方法 是让软件开发人员 服从 一个过程而非 接受 一个过程。

**敏捷开发过程**还要求开发人员必须有权做技术方面的所有决定。这样一来，就使得开发人员和管理人员在一个软件项目的领导方面有同等的地位，他们共同对整个开发过程负责。

敏捷方法还特别提倡直接的面对面交流。Alistair Cockburn 认为面对面交流的成本要远远低于文档交流的成本。因此，敏捷方法一般都按照高内聚、低耦合的原则将项目划分为若干小组，以增加沟通，提高敏捷性及应变能力。



#### 3.2 敏捷方法的核心思想

敏捷方法的核心思想主要有下面3点：

1. **敏捷方法是适应型，而非可预测型**。与传统方法不同，敏捷方法拥抱变化，可以说它的初衷就是适应变化的需求，利用变化来发展，甚至改变自己，最后完善自己。
2. **敏捷方法是以人为本，而非以过程为本**。传统方法以过程为本，强调充分发挥人的特性，不去限制它。并且软件开发在 无过程控制 和过于严格烦琐的过程控制中取得一种平衡，以保证软件的质量。
3. **迭代增量式的开发过程**。敏捷方法以原型开发思想为基础，采用迭代增量式开发，发行版本小型化。它根据客户需求的优先级和开发风险，制订版本发行计划，每一发行版都是在前一成功发行版的基础上进行功能需求扩充，最后满足客户的所有功能需求。



#### 3.3 主要敏捷方法简介

几种影响比较大的敏捷方法：

3.3.1 极限编程 

3.3.2 水晶系列方法

3.3.3 Scrum

3.3.4 特征驱动开发方法



### 4 统一过程模型 RUP

软件统一过程（Rational Unified Process，RUP）是 Rational 软件公司创造的软件工程方法。RUP 描述了如何有效地利用商业的可靠的方法开发和部署软件，是一种重量级过程。RUP类似一个在线的指导者，它可以为多有方面和层次的程序开发提供指导方针、模板以及事例支持。



#### 4.1 RUP 的生命周期

RUP 软件开发生命周期是一个二维的软件开发模型，有9个核心工作流：

- **业务建模**：Business Modeling，理解待开发系统所在的机构及其商业运作，确保所有参与人员对待开发系统所在的机构有共同的认识，评估待开发系统所在的机构的影响
- **需求**：Requirements，定义系统功能及用户界面，使客户知道系统的功能，使开发人员理解系统的需求，为项目预算及计划提供基础
- **分析与设计**：Analysis & Design，把需求分析的结果转化为分析与设计模型
- **实现**：Implementation，把设计模型转换为实现结果，对开发的代码做单元测试，将不同实现人员开发的模块集成为可执行系统
- **测试**：Test。检查各子系统之间的交互、集成，验证所有需求是否均被正确实现，对发现的软件质量上的缺陷进行归档，对软件质量提出改进建议
- **部署**：Deployment，打包、分发、安然软件，升级旧系统；培训用户及销售人员，并提供技术支持
- **配置与变更管理**：Configuration & Change Management，跟踪并维护系统开发过程中产生的所有制品的完整性和一致性
- **项目管理**：Project Management，为软件开发项目提供计划、人员分配、执行、监控 等方面的指导，为风险管理提供框架
- **环境**：Environment，为软件开发机构提供软件开发环境，即提供过程管理和工具的支持

RUP 把软件开发生命周期划分为多个**循环**（Cycle），每个循环生成产品的一个新的版本，每个循环依次由**4个连续的阶段**（Phase）组成，每个阶段完成确定的任务。这4个阶段如下：

- 初始阶段（inception）：定义最终产品视图和业务模型，并确定系统范围
- 细化阶段（elaboration）：设计及确定系统的体系结构，制订工作计划及资源要求
- 构造阶段（construction）：构造产品并继续演进需求、体系结构、计划直至产品提交
- 移交阶段（transition）：把产品提交给用户使用



#### 4.2 RUP 中的核心概念

RUP 中定义了如下一些核心概念：

- 角色（Role）：Who的问题。角色描述某个人或一个小组的行为与职责。RUP 预先定义了很多角色，如体系结构师（Architect）、设计人员（Designer）、实现人员（Implementer）、测试员（tester）、配置管理人员（Configuration Manager）等，并对每一个角色的工作和职责都做了详尽的说明
- 活动（Activity）：How的问题。活动是一个有明确目的的独立工作单元
- 制品（Artifact）：What的问题。制品是活动生成、创建或修改的一段信息。也有些书把 Artifact 翻译为产品、工件等。
- 工作流（Workflow）：When的问题。工作流描述了一个有意义的连续的活动序列，每个工作流产生一些有价值的产品，并显示了角色之间的关系



#### 4.3 RUP 的特点

RUP 是用例驱动的、以体系结构为中心的、迭代和增量的软件开发过程。

##### 4.3.1 用例驱动

RUP 中的开发活动是用例驱动的，即需求分析、设计、实现和测试等活动都是用例驱动的。

##### 4.3.2 以体系结构为中心

RUP 中的开发活动是围绕体系结构展开的。软件体系结构的设计和代码设计无关，也不依赖于具体的程序设计语言。软件体系结构是软件设计过程中的一个层次，这一层次超越计算过程中的算法设计和数据结构设计。体系结构层次的设计问题包括系统的总体组织和全局控制、通信协议、同步、数据存取、给设计元素分配功能、设计元素的组织、物理分布、系统的伸缩性和性能等。

体系结构的设计需要考虑多方面的问题：

- 在功能性特征方面要考虑系统的功能
- 在非功能性特征方面要考虑系统的性能、安全性、可用性 等
- 与软件开发有关的特征要考虑可修改性、可移植性、可重用性、可集成性、可测试性 等
- 与开发经济学有关的特征要考虑开发实际、费用、系统的生命期 等

当然，这些特征之间有些是相互冲突的，一个系统不可能在所有的特征上都达到最优，这时就需要系统体系结构设计师在各种可能的选择之间进行权衡。

对于一个软件系统，不同人员所关心的内容是不一样的。因此，软件的体系结构是一个多维的结构，也就是说，会采用多个视图来描述软件体系结构。

![图片]({{ '/images/ruankao/framework/5/4+1视图模型.png' | prepend: site.baseurl }})

- **用例视图**：展示 分析人员和测试人员关系的是系统的行为
- **逻辑视图**：展示 最终用户关系的系统功能
- **实现视图**：展示 程序员关心的系统配置、装配等问题
- **进程视图**：展示 系统集成人员关心的系统性能、可伸缩性、吞吐率 等问题
- **部署视图**：展示 系统工程师关心的系统发布、安装、拓扑结构等问题

##### 4.3.3 迭代与增量

RUP 强调采用迭代和增量的方式来开发软件，把整个项目开发分为多个迭代过程。

1. 在每次迭代中，只考虑系统的一部分需求，进行分析、设计、实现、测试、部署等过程
2. 每次迭代是在已完成部分的基础上进行的，每次增加一些新的功能实现
3. 以此进行下去，直至最后项目的完成

采用迭代与增量的方式有以下**优点**：

1. 在软件开发的早期就可以对关键的、影响大的风险进行处理
2. 可以提出一个软件体系结构来指导开发
3. 可以更好的处理不可避免地需求变更
4. 可以较早得到一个可运行地系统，鼓舞开发团队地士气，增强项目成功地信心
5. 为开发人员提供一个能更有效工作地开发过程。



### 5 软件能力成熟度模型

**软件能力成熟度模型** （Capability Maturity Model for Software，**CMM**）是一个概念模型。模型框架和表示是刚性地，不能随意改变，但模型地解释和实现有一定弹性。

**软件能力成熟度模型集成**（Capability Maturity Model Integration for Software，**CMMI**）是在 CMM 的基础上发展而来。主要用于指导软件开发过程的改进和进行软件开发能力的评估。

CMMI 提供了一个软件能力成熟度的框架，它将软件过程改进的步骤组织成5个成熟度等级，共包括：18个关键过程域，52个过程目标，3168种关键时间，它为软件过程不断改进奠定了一个循序渐进的基础。



#### 5.1 初始级

- 该等级下，过程通常是随意且混乱的。
- 这些组织的成功 依赖于组织内人员的能力与英雄主义。
- 这些组织也能产出能用的产品与服务，但它们经常超出在计划中记录的预算与成本

#### 5.2 已管理级

- 该等级下，意味着组织要确保策划、文档化、执行、监督和控制 项目级的过程
- 需要为过程建立明确的目标，并能实现成本、进度、质量目标 等

#### 5.3 已定义级

- 该等级下，企业能够根据自身的特殊情况定义适合自己企业和项目的标准流程
- 将这套管理体系与流程予以制度化，同时企业开始进行项目积累，企业资产的收集

#### 5.4 量化管理级

- 该等级下，组织建立了产品质量、服务质量以及过程性能的定量目标
- 与上一等级的区别 在于对过程性能的可预测

#### 5.5 优化级

- 该等级下，企业的项目管理达到了最高的境界
- 关注于通过增量式的 与 创新式 的过程与技术改进，不断地改进过程性能
- 组织使用从多个项目收集来的数据对整体的组织级绩效进行关注



## 二、需求工程

软件需求目前并没有统一的定义，但都包含以下几方面的内容：

1. 用户解决问题或达到目标所需条件或权能（Capability）。
2. 系统或系统部件要满足 合同、标准、规范 或 其他正式规定文档 所需具有的条件或权能。
3. 一种反映上面 ① 或 ② 所述条件或权能的文档说明。它包括 **功能性需求** 及 **非功能性需求**，非功能性需求对设计和实现提出了限制，比如：性能要求、质量标准、设计限制 等

需求阶段的输出成果为 **用户原始需求说明书** 和 **软件需求描述规约**。需求阶段首先要定义用户的原始需求，并于用户、客户 达成一致；其次，需要对这对原始需求进行分析，给出一个初步的软件解决方案，并给出该软件的需求描述规约，以指导后续的软件开发。

软件需求包括3个不同的层次：**业务需求**、**用户需求**、**功能需求**（也包括非功能需求）

1. **业务需求**：反应了组织机构或客户对系统、产品高层次的目标要求
2. **用户需求**：描述了用户使用产品必须要完成的任务，式用户对该软件产品的期望
3. **功能需求**：定义了开发人员必须实现的软件功能，使得用户能完成它们的任务，从而满足业务需求。

所谓 **特性**（feature）是指逻辑上相关的功能需求的集合，给用户提供处理能力并满足业务需求。作为补充，软件需求规格说明还应包括非功能需求，它描述了系统展现给用户的行为和执行的操作等。它包括：

- 产品必须遵从的标准、规范、合约
- 外部界面的具体细讲
- 性能要求
- 设计或实现的约束条件：是指对开发人员在软件产品设计和构造上的限制，常见的有设计约束和过程约束
- 质量属性：是通过多种角度对产品的特点进行描述，从而反应产品功能

**需求工程** 是指应用已证实有效的原理、方法，通过合适的工具和记号，系统地描述待开发系统及其行为特征和相关约束。 **需求工程**覆盖了体系结构设计之前的各项**开发活动**，主要包括分析客户要求、对未来系统的各项功能性及非功能性需求进行规格说明。

**需求工程的活动阶段**：

1. **需求获取**：通过与用户的交流，对现有系统的观察及对任务进行分析，从而开发、捕获、修订用户的需求
2. **需求分析**：为系统建立一个概念模型，作为对需求的抽象描述，并尽可能多的捕获现实世界的语义。
3. **形成需求规格**（需求文档化）：按照相关标准，生成需求模型的文档描述，用户原始需求书作为用户和开发者之间的一个协约，往往被作为合同的附件；软件需求描述规约作为后续软件系统开发的指南
4. **需求确认与验证**：以需求规格说明为输入，通过用户确认、复审会议、符号执行、模拟仿真、快速原型 等途径与方法，确认和验证需求规格的完整性、正确性、一致性、可测试性、可行性，包含有效性检查、一致性检查、可行性检查、确认可验性
5. **需求管理**：包括需求文档的追踪管理、变更控制、版本控制等管理性活动

软件需求开发的最终文档经过评审批准后，则定义了开发工作的**需求基线**。这个基线在客户和开发者之间构筑了计划产品功能需求和非功能需求的一个约定。**需求约定**是 需求开发 和 需求管理 之间的桥梁。

**需求管理** 是对一个系统需求**变更**、**了解**和**控制**的过程。需求管理过程与需求开发过程相互关联，当初始需求导出的同时就启动了需求管理规划，一旦形成了需求文档的初稿，需求管理活动就开始了。**需求管理的主要活动**：

1. 变更控制：建议变更、分析影响、做出决策、交流、合并、测量需求的稳定性
2. 版本控制：确定需求文档版本、确定单个需求文档版本
3. 需求跟踪：定义对其他需求的连接链、定义对其他系统元素的连接链
4. 需求状态跟踪：定义需求状态、跟踪需求每一个状态

**需求管理强调的内容**如下：

1. 控制对需求基线的变动
2. 保持项目计划与需求一致
3. 控制单个需求和需求文档的版本情况
4. 管理需求和联系链，或管理单个需求和其他项目可交付产品之间的依赖关系
5. 跟踪基线中的需求状态



### 1 需求获取

**需求陈述的内容**包括：**问题范围**、**功能需求**、**应用环境**、**假设条件** 等。此外，也包含涉及相关**软件工程标准**、**技术方案**、将来可能做的**扩充及可维护性要求**等方面的约束条件。需求陈述应该阐明 做什么 而不是 怎么做。

**需求获取**是开发者、用户之间为了定义新系统而进行的交流，需求获取是获得系统必要的特征，或者是获得用户能接受的、系统必须满足的约束。



#### 1.1 需求获取的基本步骤

对于不同规模及不同类型的项目，需求获取的过程不会完全一样，下面给出需求获取过程的参考步骤：

1. **开发高层的业务模型**：建立一个业务模型，描述用户的业务过程，确定用户的初始需求。然后通过迭代，更深入地了解应用领域，之后再对业务模型进行改进。
2. **定义项目范围和高层需求**：即在项目开始之前，在所有涉众之间建立共同的项目愿景。项目范围 描述系统的边界以及系统与系统交互的参与者之间的关系（包括组织、人、硬件设备、其他软件等）。高层需求不涉及过多的细节，主要表示系统需求的概貌。常见的建模手段包括**系统上下文图**、**系统顶层用例图** 等。
3. **识别用户角色和用户代表**：涉众不仅包括传统的用户、客户等，还包括测试人员、维护人员、市场人员等，他们也对项目有利益诉求。因此，首先确定所有涉众，然后挑选出每一类涉众并与他们一起工作。用户角色可以是人，也可以是与系统打交道的其他应用程序或硬件部件。如果是其他应用程序或硬件部件，则需要以熟悉这些系统或硬件的人员作为用户代表。
4. **获取具体的需求**：确定了项目范围和高层需求，并确定了所有涉众后，就需要获取每个涉众的具体、完整、详细的需求
5. **确定目标系统的业务工作流**：具体到当前待开发的应用系统，确定系统的业务工作流和主要的业务规则。往往需要采取多重方法来获取所需的信息。
6. **需求整理与总结**：最后对上面步骤取得的需求资料进行整理和总结，确定对软件系统的综合要求，即软件的需求。并提出这些需求的实现条件，以及需求应达到的标准。这些需求包括功能需求、性能需求、环境需求、可靠性需求、安全保密需求、用户界面需求、资源使用需求、软件成本消耗与开发进度需求等。



#### 1.2 需求获取方法

针对不同类型的软件项目，需要采用不同的**需求获取方法**，常见的有：

1. **用户面谈**：这是一种最常见的需求获取方法，是理解用户需求的最有效方法。
   - 面谈过程需要认真的计划和准备；
   - 面谈之后，需要复查笔记的准确性、完整性、可理解性
   - 把所收集的信息转化为适当的模型和文档
   - 确定需要进一步澄清的问题
2. **需求专题讨论会**：在短暂而紧凑的时间段内将相关涉众集中在一起集体讨论，与会者可以在应用需求上达成共识，对操作过程尽快取得统一的意见。参加会议的人员包括主持人、用户、技术人员、项目组人员。专题讨论会具有以下优点：
   - 协助建立一支高效的团队，围绕项目成功的目标
   - 所有的风险承担人都畅所欲言
   - 促进风险承担人和开发团队之间达成共识
   - 揭露和解决那些妨碍项目成功的行政问题
   - 能够很快地产生初步地系统定义
   - 可以有效地解决不同涉众之间地需求冲突
3. **问卷调查**：问卷调查可用于确认假设和收集统计倾向数据。存在地问题是：相关问题不能事先决定，问题背后地假设对答案造成偏颇，难以探索一些新领域，难以继续用户地模糊响应。在完成最初地面谈和分析后，问卷调查可作为一项协作技术收到良好效果
4. **现场观察**：该方法主要是通过观察用户实际执行业务的过程，来直观地了解业务地执行过程，全面了解需求细节。执行业务可能是手工操作，也可能是在原有地业务系统上执行
5. **原型化方法**：在需求的早期，用户往往在具体的需求定义上存在很多不确定性，尤其是信息系统的人机交互界面和查询报表类的需求上。此时往往可以通过在需求阶段采用原型化方法，通过开发系统原型以及与用户的多次迭代反馈，解决在早期阶段需求不确定的问题，尤其是在人机界面等高度不确定的需求
6. **头脑风暴法**：在一些新业务拓展的软件项目中，由于业务是新出现的，而且业务流程存在高度的不确定性，例如互联网上的新业务系统、APP等，一群人围绕该业务，发散思维，不断产生新的观点，参会者敞开思想使各种设想在相互碰撞中激起大脑的创造性风暴，从而确定具体的需求



### 2 需求变更

需求变更的原因有很多种：

- 可能是需求获取不完整，存在遗漏
- 可能是对需求的理解产生了误差
- 可能是业务变化导致了需求的变化

软件需求文档应该精确描述要交付的产品，这是一个基本的原则。为了使开发组织能够严格控制软件项目，应该确保：

- 仔细评估已建议的变更
- 挑选合适的人选对变更做出判定
- 变更应及时通知所有相关人员
- 项目要按一定的程序来采纳需求变更，对变更的过程和状态进行控制



#### 2.1 变更控制过程

变更控制过程用来**跟踪已建议变更的状态**，一旦确定了需求基线，应该使所有已建议的变更都遵循变更控制过程。

![图片]({{ '/images/ruankao/framework/5/需求变更管理过程.png' | prepend: site.baseurl }})

1. **问题分析和变更描述**：当提出一份变更提议后，需要对该提议做进一步的问题分析，检查它的有效性，从而产生一个更明确的需求变更提议。
2. **变更分析和成本计算**：当接受该变更提议后，需要对需求变更提议进行影响分析和评估。变更成本计算应该包括对该变更所引起的所有改动的成本。例如修改需求文档、相应的设计、实现等工作成本。
3. **变更实现**：当确定执行该变更后，需要根据该变更的影响范围，按照开发的过程模型执行相应的变更。
   - 在计划驱动过程模型中，往往需要回溯到需求分析阶段开始，重新作对应的需求分析、设计、实现等步骤；
   - 在敏捷开发模型中，往往会将需求变更纳入到下一次迭代的执行过程中

变更控制过程并不是给变更设置障碍。相反，她是一个渠道和过滤器，通过它可以确保采纳最合适的变更，使变更产生的负面影响降到最低。

**常见的需求变更策略**：

1. 所有需求变更必须遵循变更控制过程
2. 对于未获得批准的变更，不应该做设计和实现工作
3. 变更应该由项目变更控制委员会决定实现哪些变更
4. 项目风险承担者应该能够了解变更的内容
5. 绝不能从项目配置库中删除或者修改变更请求的原始文档
6. 每一个集成的需求变更必须能跟踪到一个经核准的变更请求，以保持水平可追踪性



#### 2.2 变更控制委员会

变更控制委员会（Change Control Board，CCB）是项目所有者权益代表，负责裁定接受哪些变更。CCB 由项目所涉及的多方成员共同组成，通常包括用户和实施方的决策人员。CCB 是决策机构，不是作业机构，通常 CCB 的工作是通过评审手段来决定项目是否能变更，但不提出变更方案。

变更控制委员会应该有一个总则，用于描述变更控制委员会的目的、授权范围、成员构成、做出决策的过程及操作步骤。总则也应该说明举行会议的频度和事由。管理范围描述该委员会能做什么样的决策，以及有哪一类决策应上报到高一级的委员会。过程及操作步骤如下：

1. 制定决策
2. 交流情况
3. 重新协商约定



### 3 需求追踪

需求跟踪包括编制每个需求同系统元素之间的联系文档，这些元素包括其他需求、体系结构、其他设计部件、源代码模块、测试、帮助文件、文档等，是要在整个项目的工件之间形成水平可追踪性。跟踪能力信息使变更影响分析十分便利，有利于确认和评估实现某个建议的需求变更所必须的工作。

需求跟踪提供了由需求到产品实现整个过程范围的明确查阅的能力。**目的**是建立与维护 需求->设计->编程->测试 之间的一致性，确保所有的工作成果符合用户需求。

需求跟踪的两种方式：

1. 正向跟踪：检查 **产品需求规格说明书** 中的每个需求是否能在后继工作成果中找到对应点
2. 逆向跟踪：检查设计文档、代码、测试用例等工作成功是否都能在 产品需求规格说明书 中找到出处



## 三、系统分析与设计

**系统分析阶段** 是应用系统思想和方法，把复杂的对象分解为简单的组成部分，找出这些部分的基本属性和彼此之间的关系的过程，其基本任务是系统分析师和用户在充分了解用户需求的基础上，把双方对新系统的理解表达为系统需求规格说明书。

**系统设计** 的目标是根据系统分析的结果，完成系统的构建过程。其主要目的是绘制系统的蓝图，权衡和比较各种技术和实施方法的利弊，合理分配各种资源，构建新系统的详细设计方案和相关模型，指导系统实施工作的顺利开展。

**系统设计的主要内容**包括 **概要设计** 和 **详细设计**。



### 1 结构化方法

**结构化方法**（Structured Analysis and Structured Design，SASD）也可称为**面向功能的软件开发方法 **或 **面向数据流的软件开发方法**。

结构化开发方法提出了一组**提高软件结构合理性的准则**，如 **分解与抽象**、**模块独立性**、**信息隐蔽** 等。针对软件生存周期各个不同的阶段，它有**结构化分析**（SA）、**结构化设计**（SD）、**结构化编程**（SP）等方法。



#### 1.1 结构化分析

结构化分析方法给出一组帮助系统分析人员产生功能规格的原理与技术。它一般利用图形表达用户需求，使用的手段主要有**数据流图**、**数据字典**、**结构化语言**、**判定表**以及**判定树**等。

**结构化分析的步骤**如下：

1. 分析业务情况，做出反映当前物理模型的数据流图（Data Flow Diagram，DFD）
2. 推导出等价的逻辑模型的DFD
3. 设计新的逻辑系统，生产数据字典和基元描述
4. 建立人机接口，提出可供选择的目标系统物理模型的DFD
5. 确定各种方案的成本和风险等级，据此对各种方案进行分析
6. 选择一种方案
7. 建立完整的需求规约

##### 1.1.1 数据流图

**DFD 需求建模**方法，也称为**过程建模**和**功能建模**方法。DFD建模方法的核心是**数据流**，从应用系统的数据流着手以图形方式刻画和表示一个具体业务系统中的数据处理过程和数据流。DFD建模方法首先抽象出具体应用的主要业务流程，然后分析其输入，如其初始的数据有哪些，这些数据从哪里来，将流向何处，又经过了什么加工，加工后又变成了什么数据，这些数据流最终将得到什么结果。

通过对系统业务流程的层层追踪和分析把要解决的问题清晰地展现及描述出来，为后续的设计、编码、实现系统的各项功能打下基础。

DFD方法由4种基本元素（模型对象）组成：**数据流**、**处理/加工**、**数据存储**、**外部项**。

1. 数据流（Data Flow）：数据流用一个箭头描述数据的流向，箭头上标注的内容可以是信息说明或数据项
2. 处理（Process）：表示对数据进行的加工和转换，在图中用矩形框表示。指向处理的数据流为该处理的输入数据，离开处理的数据流为该处理的输出数据
3. 数据存储：表示用数据库形式（或文件）存储的数据，对其进行的存取分别以指向或离开数据存储的箭头表示
4. 外部项：也称为数据源或者数据终点。描述系统数据的提供者或者数据的使用者，如教师、学生、采购员、某个组织或部门或其他系统，在图中用圆角框或者平行四边形框表示

**建立DFD图的目的是描述系统的功能需求**。DFD方法利用应用问题域中数据及信息的提供者与使用者、信息的流向、处理、存储 4种元素描述系统需求，建立应用系统的功能模型。具体的建模过程及步骤如下：

1. 明确目标，确定需求范围
   首先要明确目标系统的功能需求，并将用户对目标系统的功能需求完整、准确、一致地描述出来，然后确定模型要描述地问题域。虽然在建模过程中这些内容是逐步细化地，但必须自始至终保持一致、清晰、准确
2. 建立顶层 DFD 图
   顶层 DFD 图表达和描述了将要实现地系统的主要功能，同时也确定了整个模型的内外关系，表达了系统的边界及范围，也构成了进一步分解的基础
3. 构建第一层 DFD 图
   根据应用系统的逻辑功能，把顶层 DFD 图中的处理分解成多个更细化的处理
4. 开发 DFD 层次结构图
   对第一层 DFD 分解图中的每个处理框作进一步分解，在分解图中要列出所有的处理及其相关信息，并要注意分解图中的处理与信息包括父图中的全部内容。分解可采用以下原则：
   - 保持均匀的模型深度；
   - 按困难程度进行选择
   - 如果一个处理难以确切命名，可以考虑对它重新分解
5. 检查确认 DFD 图
   按照规则检查和确定 DFD 图，以确保构建的 DFD 模型是正确的、一致的、且满足要求。具体规则包括：
   - 父图中描述过的数据流必须要在相应的子图中出现
   - 一个处理至少有一个输入流和一个输出流
   - 一个存储必读有流入的数据流和流出的数据流
   - 一个数据流至少有一端是处理端
   - 模型图中表达和描述的信息是全面的、完整的、正确的、一致的

经过以上过程与步骤后，顶层图被逐层细化，同时也把面向问题的术语逐渐转化为面向现实的解法，并得到最终的 DFD 层次结构图。层次结构图中的上一层是下一层的抽象，下一层是上一层的求精和细化，而最后一层中的每个处理都是面向一个具体的描述，即一个处理模块仅描述和解决一个问题。



##### 1.1.2 数据字典

数据字典（Data Dictionary）是一种用户可以访问的记录数据库和应用程序元数据的目录。**数据字典**是指对数据的**数据项**、**数据结构**、**数据流**、**数据存储**、**处理逻辑**等进行定义和描述，其**目的**是对数据流程图中的各个元素做出详细的说明。简而言之，数据字典是描述数据的信息集合，是对系统中使用的所有数据元素定义的集合。

数据字典最重要的作用是**作为分析阶段的工具**。任何字典最重要的用途都是供人查询，在结构化分析中，**数据字典的作用是给数据流图上每个元素加以定义和说明**。换句话说，**数据流图上所有元素的定义和解释的文字集合就是数据字典**。数据字典中建立的严密一致的定义，有助于改进分析员和用户的通信与交互。数据字典各部分的描述如下：

1. **数据项**：数据流图中数据块的数据结构中的数据项说明。数据项是不可再分的数据单位。通常包括以下内容：
   - 数据项描述 = {数据项名，数据项含义说明，别名，数据类型，长度，取值范围，取值含义，与其他数据项的逻辑关系}
   - 取值范围、与其他数据项的逻辑关系 定义了数据完整性约束条件，是设计数据检验功能的依据。若干个数据项可以组成一个数据结构。
2. **数据结构**：数据流图中数据块的数据结构说明。数据结构反映了数据之间的组合关系。一个数据结构可以由若干个数据项组成，也可以由若干个数据结构组成，或由若干个数据项和数据结构混合组成。通常包括以下内容：
   - 数据结构描述 = {数据结构名，含义说明，组成：{数据项或数据结构}}
3. **数据流**：数据流图中流线的说明。数据流是数据结构再系统内传输的路径。通常包括以下内容：
   - 数据流描述 = {数据流名，说明，数据流来源，数据流去向，组成：{数据结构}，平均流量，高峰期流量}
   - 数据流来源 是说明该数据流来自哪个过程
   - 数据流去向 是说明该数据流将到哪个过程去
   - 平均流量 是指在单位时间里的传输次数
   - 高峰期流量 是指在高峰时期的数据流量
4. **数据存储**：数据流图中数据块的存储特性说明。数据存储是数据结构停留或保存的地方，也是数据的来源和去向之一。通常包括以下内容：
   - 数据存储描述 = {数据存储名，说明，编号，流入的数据流，流出的数据流，组成：{数据结构}，数据量，存取方式}
   - 数据量 是指每次存取多少数据，每天(小时/周)存取几次等信息
   - 存取方式 包括批处理、联机处理、检索(顺序检索/随机检索)、更新
   - 流入的数据流要指出其来源，流出的数据流要指出其去向
5. **处理过程**：数据流图中功能块的说明。数据字典中只需要描述处理过程的说明性信息，通常包括以下内容：
   - 处理过程描述 = {处理过程名，说明，输入：{数据流}，输出：{数据流}，处理：{简要说明}}
   - 简要说明 中主要说明该处理过程的功能及处理要求。功能是指该处理过程用来做什么（并不是怎样做）
   - 处理要求 包括处理频度要求，如单位时间处理多少事务，多少数据量，响应时间要求等，这些处理要求是后面物流设计的输入及性能评价标准



#### 1.2  结构化设计

结构化设计（Structured Design，SD）是一种面向数据流的设计方法，它以 SRS 和 SA 阶段所产生的数据流图和数据字典等文档为基础，是一个自顶向下、逐步求精和模块化的过程。SD方法的基本思想是将软件设计成由相对独立且具有单一功能的模块组成的结构，分为**概要设计**和**详细设计**两个阶段：

- **概要设计** 的主要任务是确定软件系统的结构，对系统进行模块划分，确定每个模块的功能、接口和模块之间的调用关系；
- **详细设计** 的主要任务是为模块设计实现的细节



##### 1.2.1 模块结构

系统是一个整体，它具有整体性的目标和功能，但这些目标和功能的实现又是由相互联系的各个组成部分共同工作的结果。人们在解决复杂问题时使用的一个很重要的原则，就是将它分解成多个小问题分别处理，在处理过程中，需要根据系统总体要求，协调各业务部门的关系。在 SD 中，这种功能分解就是将系统划分为模块，模块是组成系统的基本单位，它的**特点是可以自由组合、分解、变换**，系统中任何一个处理功能都可以看成一个模块。



###### 1.2.1.1 信息隐藏与抽象

​    **信息隐藏原则**要求采用封装技术，将程序模块的实现细节（过程或数据）隐藏起来，对于不需要这些信息的其他模块来说是不能访问的，使模块接口尽量简单。按照信息隐藏的原则，系统中的模块应设计成 黑盒，模块外部只能使用模块接口说明中给出的信息，例如：操作和数据类型等。模块之间相对独立，既易于实现，也易于理解和维护。
​    **抽象原则**要求抽取事物最基本的特性和行为，忽略非本质的细节，采用分层次抽象的方式可以控制软件开发过程的复杂性，有利于软件的可理解性和开发过程的管理。通常，抽象层次包括**过程抽象**、**数据抽象**、**控制抽象**。



###### 1.2.1.2 模块化

在 SD 方法中，模块使实现功能的基本单位，它一般具有功能、逻辑、状态 3个基本属性：

- 功能是指该模块 做什么
- 逻辑是描述模块内部 怎么做
- 状态是该模块使用时的环境和条件

在描述一个模块时，必须按模块的外部特性与内部特性分别描述。

- 外部特性 是指模块名、参数表和给程序乃至整个系统造成的影响
- 内部特性 是指完成其功能的程序代码和仅供该模块内部使用的数据

对于模块的外部环境来说，只需要了解这个模块的外部特性就足够了，不必了解他的内部特性。而软件设计阶段，通常是先确定模块的外部特性，然后再确定它的内部特性。



###### 1.2.1.3 耦合

耦合表示模块之间联系的程度。紧密耦合 表示模块之间联系非常强；松散耦合 表示模块之间联系比较弱；非直接耦合 表示模块之间无任何直接联系。

模块的耦合类型通常分为7种，耦合度从低到高排序如下：

|  耦合类型  | 描述                                                         |
| :--------: | :----------------------------------------------------------- |
| 非直接耦合 | 两个模块之间没有直接关系，他们之间的联系完全是通过上级模块的控制和调用来实现的 |
|  数据耦合  | 一组模块借助参数表传递简单数据                               |
|  标记耦合  | 一组模块通过参数表传递记录等 复杂信息（数据结构）            |
|  控制耦合  | 模块之间传递的信息中包含用于控制模块内部逻辑的信息           |
|  通信耦合  | 一组模块共用了一组输入信息，或者它们的输出需要整合以形成完整数据，即共享了输入或输出 |
|  公共耦合  | 多个模块都访问同一个公共数据环境，公共的数据环境可以是全局数据结构、共享的通信区、内存的公共覆盖区等 |
|  内容耦合  | 一个模块直接访问另一个模块的内部数据<br />一个模块不通过正常入口转到另一个模块内部<br />两个模块有一部分程度代码重叠<br />一个模块有多个入口等 |

对于模块之间耦合的强度，主要依赖于 一个模块对另一个模块的调用、一个模块向另一个模块传递的数据量、一个模块施加到另一个模块的控制的多少，以及模块之间接口的复杂程度



###### 1.2.1.4 内聚

内聚表示模块内部各代码成分之间联系的紧密程度，是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做目标单一的一件事情。

模块的内聚类型通常也可以分为7种，内聚度从高到低的排序如下：

| 内聚类型 | 描述                                         |
| -------- | -------------------------------------------- |
| 功能内聚 | 完成一个单一功能，各个部分协同工作，缺一不可 |
| 顺序内聚 | 处理元素相关，而且必须顺序执行               |
| 通信内聚 | 所有处理元素集中在一个数据结构的区域上       |
| 过程内聚 | 处理元素相关，而且必须按特定的次序执行       |
| 时间内聚 | 所包含的任务必须在同一时间间隔内执行         |
| 逻辑内聚 | 完成逻辑上相关的一组任务                     |
| 偶然内聚 | 完整一组没有关系或松散关系的任务             |

一般来说，系统中各模块的内聚越高，则模块间的耦合就越低，但这种关系并不是绝对的。耦合低使得模块间尽可能相对独立，各模块可以单独开发和维护；内聚高使得模块的可理解性和维护性大大增强。因此，在模块的分解中应尽量减少模块的耦合，力求增加模块的内聚，遵循 高内聚、低耦合 的设计原则



##### 1.2.2 系统结构图

系统结构图（Structure Chart，SC）又称为**模块结构图**，它是软件概要设计阶段的工具，反映系统的功能实现和模块之间的联系与通信，包括各模块之间的层次结构，即反映了系统的总体结构。在系统分析阶段，系统分析师可以采用 SA 方法获取由 DFD、数据字典 和 加工说明等组成的系统的逻辑模型；在系统设计阶段，系统设计师可根据一些规则，从 DFD 中导出系统初始的 SC。

详细设计的主要任务是设计每个模块的实现算法、所需的局部数据结构。详细设计的目标有两个：**实现模块功能的算法要逻辑上正确** 和 **算法描述要简明易懂**。详细设计必须遵循概要设计来进行。详细设计方案的更改，不得影响到概要设计方案；如果需要更改概要设计，必须经过项目经理的同意。详细设计，应该完成详细设计文档，主要是模块的详细设计方案说明。

**设计的基本步骤**如下：

1. 分析并确定输入/输出数据的逻辑结构
2. 找出输入数据结构和输出数据结构中有对应关系的数据单元
3. 按一定的规则由输入、输出的数据结构导出程序结构
4. 列出基本操作与条件，并把它们分配到程序结构图的适当位置
5. 用伪码写出程序

详细设计的**表示工具**有图形工具、表格工具、语言工具：

1. **图形工具**
   利用图形工具可以把过程的细节用图形描述出来。具体的图形有业务流图、程序流程图、PAD（Problem Analysis Diagram）图、NS 流程图。
   - **程序流程图** 又称为程序框图，是使用最广泛的一种描述程序逻辑结构的工具。它用**方框表示一个处理步骤**，**菱形表示一个逻辑条件**，**箭头表示控制流向**。
     - **优点**：结构清晰，易于理解，易于修改。
     - **缺的**：只能描述执行过程而不能描述有关的数据。
   - **NS 流程图** 也称为盒图，是一种强制使用结构化构造的图示工具，也称为方框图。其具有以下特点：功能域明确、不可能任意转移控制、很容易确定局部和全局数据的作用域、很容易表示嵌套关系及模板的层次关系。
   - **PAD图** 是一种改进的图形描述方式，可以用来取代程序流程图，相比程序流程图更直观，结构更清晰。最大的优点是能够反映和描述自顶向下的历史和过程。PAD 提供了5种基本控制结构的图示，并允许递归使用。PAD的特点如下：
     - 使用 PAD 符合设计出的程序代码是结构化程序代码
     - PAD 所描绘的程序结构十分清晰
     - 用 PAD 图表现程序的逻辑易读、易懂、易记
     - 容易将 PAD 图转换成高级语言源程序自动完成
     - 既可以表示逻辑，也可以用来描绘数据结构
     - 支持自顶向下方法的使用
2. **表格工具**
   可以用一张表来描述过程的细节，在这张表中列出了各种可能的操作和相应的条件
3. **语言工具**
   用某种高级语言来描述过程的细节，例如 **伪码** 和 **PDL**（Program Design Language）等。
   - **PDL** 也可称为伪码或结构化语言，它用于描述模块内部的具体算法，以便开发人员之间比较精确地进行交流。语法是开放式地，其外层语法是确定地，而内层语法则不确定。外层语法描述控制结构，它用类似于一般编程语言控制结构地关键字表示，所以是确定的。内层语法描述具体操作，考虑到不同软件系统的实际操作种类繁多，内层语法因而不确定，它可以按系统的具体情况和不同的设计层次灵活选用
     - 优点：可以作为注释直接插在源程序中；可以使用普通的文本编辑工具或文字处理工具产生和管理；已经有自动处理程序存在，而且可以自动由 PDL 生成程序代码
     - 不足：不如图形工具形象直观，描述复杂的条件组合与动作间对应关系时，不如判定树清晰简单



#### 1.3 结构化编程

结构化程序设计（Structured Programing，SP）

**面向结构的程序设计方法** 即结构化程序设计方法，是 **面向过程** 方法的改进，结构上将软件系统划分为若干功能模块，各模块要求单独编程，再组合构成相应的软件系统。该方法强调程序的结构性，所以容易做到易读易懂。该方法思路清晰，做法规范，程序的出错率和维护费用大大减少。

结构化程序设计采用**自顶向下**、**逐步求精**的设计方法，各个模块通过 **顺序**、**选择**、**循环** 的控制结构进行连接，并且只有一个入口和一个出口。

**结构化程序设计的原则**可表示为：程序 = 算法 + 数据结构。
算法是一个独立的整体，数据结构（包含数据类型与数据）也是一个独立的整体。两者分开设计，以算法（函数或过程）为主。

结构化程序设计提出的原则可以归纳为32个字：

- 自顶向下，逐步细化
- 清晰第一，效率第二
- 书写规范，缩进格式
- 基本结构，组合而成



#### 1.4 数据库设计

数据库设计是指根据用户的需求，在某一具体的数据库管理系统上，设计数据库的结构和建立数据库的过程。数据库设计的内容包括：**需求分析**、**概念结构设计**、**逻辑结构设计**、**物理结构设计**、**数据库的实施**、**数据库的运行**、**维护**。



##### 1.4.1 概念结构设计

概念结构设计是对用户要求描述的现实世界 通过对其中实体事物的分类、聚集、概括，建立抽象的概念数据模型。这个概念模型反映现实世界各部门的信息结构、信息流动情况、信息间的互相制约关系以及各部门对信息储存、查询和加工的要求等。通常采用**实体-联系图**（Entity Relationship Diagram，**E-R图**）来表示。

E-R图提供了表示**实体类型**、**属性**、**联系** 的方法，用来描述现实世界的概念模型。它是描述现实世界关系概念模型的有效方法，是表示概念关系模型的一种方式。

在E-R图中有如下成分：**矩形框表示实体**、**菱形框表示联系**、**椭圆形框表示实体或联系的属性**，对于主属性名，则在其名称下画一条下划线。

1. **实体**：一般认为，客观上可以相互区分的事物就是实体，实体可以是具体的人和物，也可以是抽象的概念与联系。关键在于一个实体能与另一个实体相区别，具有相同属性的实体具有相同的特征和性质。用实体名及其属性名集合来抽象和刻画同类实体。在E-R图中用矩形表示，矩形框内写明实体名；
2. **属性**：实体所具有的某一特性，一个实体可由若干个属性来刻画。属性不能脱离实体，属性是相对实体而言的。在E-R图中用椭圆形表示，并用无向边将其与相应的实体连接起来。
   - 如果是多值属性的话，在椭圆形外面再套实现椭圆
   - 如果是派生属性则用虚线椭圆表示
3. **联系**：联系也称关系，信息世界中反映实体内部或实体之间的关联。实体内部的联系通常是指组成实体的各属性之间的联系；实体之间的联系通常是指不同实体集之间的联系。在E-R图中用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来，同时在无向边旁标上联系的类型（1:1，1:n，m:n）。

E-R图中的联系存在3种一般性约束：一对一约束(联系)、一对多约束、多对多约束，他们用来描述实体集之间的数量约束。

联系也可能有属性。例如：学生"选修"某课程所取得的成绩，成绩既不是学生的属性也不是课程的属性，是学生与课程之间的联系"选修"的属性。

**E-R图的基本作图步骤**如下：

1. 确定所有的实体集合
2. 选择每个实体集应该包含的属性
3. 确定实体集之间的联系
4. 确定实体集的关键字，用下划线在属性上表明关键字的属性组合
5. 确定联系的类型，在用线将表示联系的菱形框联系到实体集时，在线旁注明是1或n来表示联系的类型



### 2 面向对象方法

面向对象（Object-Oriented，OO）开发方法将面向对象的思想应用于软件开发过程中，指导开发活动，是建立在“对象”概念基础上的方法学。面向对象方法的本质是主张参照人们认识一个现实系统的方法，完成分析、设计、实现一个软件系统，提倡用人类在现实生活中常用的思维方法来认识和理解描述客观事物，强调最终建立的系统能映射问题域，使得系统中的对象，以及对象之间的关系能够如实地反映问题域中固有地事物及其关系。

面向对象开发方法认为客观世界是由对象组成地，对象由属性和操作组成，对象可按其属性进行分类，**对象之间的联系通过传递消息来实现**，对象具有**封装性**、**继承性**、**多态性**。

面向对象开发方法是 **以用例驱动的**、**以体系结构为中心的**、**迭代**的和**渐增式**的开发过程，主要包括**需求分析**、**系统分析**、**系统设计**、**系统实现** 4个阶段，但是，各个阶段的划分不像结构化开发方法那样清晰，而是再各个阶段之间迭代进行的。



#### 2.1 面向对象分析

面向对象的分析方法（Object-Oriented Analysis，OOA），是在一个系统的开发过程中进行了系统业务调查以后，按照面向对象的思想来分析问题。OOA 与结构化分析有较大的区别。OOA 所强调的是在系统调查资料的基础上，针对 OO 方法所需要的素材进行的归类分析和整理，而不是对管理业务现状和方法的分析。

OOA 模型由 **5个层次**（**主题层**、**对象类层**、**结构层**、**属性层**、**服务层**）和 **5个活动**（**标识对象类**、**标识结构**、**定义主题**、**定义属性**、**定义服务**）组成。在这种方法中定义了两种对象类之间的结构，一种称为分类结构；另一种称为组装结构。

- 分类结构就是所谓的一般与特殊的关系
- 组装结构则反映了对象之间的整体与部分的关系



##### 2.1.1 OOA原则

OOA的基本原则包括如下内容：

| 原则     | 介绍                                                         |
| -------- | ------------------------------------------------------------ |
| 抽象     | 抽象是从许多事物中舍弃个别的、非本质的特征，抽取共同的、本质性的特征。<br />抽象是形成概念的必要手段。<br />抽象是面向对象方法中使用最为广泛的原则。<br />抽象原则包括：过程抽象、数据抽象。<br />- 过程抽象：任何一个完成确定功能的操作序列，其使用者都可以把它看作一个单一的实体，尽管实际上它可能是由一系列更低级的操作完成的<br />- 数据抽象：根据施加于数据之上的操作来定义数据类型，并限定数据的值只能由这些操作来修改和观察。数据抽象是 OOA 的核心原则。它强调把数据(属性)和操作(服务)结合为一个不可分的系统单位(即对象)，对象的外部只需要知道它做什么，而不必知道它如何做 |
| 封装     | 封装就是把对象的属性和服务结合为一个不可分的系统单位，并尽可能隐蔽对象内部细节。<br />这个概念也经常用于从外部隐藏程序单元的内部表示或状态 |
| 继承     | 特殊类的对象拥有其对应的一般类的全部属性与服务，称作特殊类对一般类的继承。<br />在 OOA 中运用继承原则，在特殊类中不再重复地定义一般类中已定义的东西，但是，在语义上，特殊类却自动地、隐含地拥有一般类(以及所有更上层的一般类)中定义的全部属性和服务。<br />继承原则的好处是：是系统模型比较简练，比较清晰。 |
| 分类     | 分类就是把具有相同属性和服务的对象划分为一类，用类作为这些对象的抽象描述。<br />分类原则实际上是抽象原则运用于对象描述时的一种表现形式 |
| 聚合     | 聚合又称组装，其原则是：把一个复杂的事物看成若干比较简单的事物的组装体，从而简化对复杂事物的描述。 |
| 关联     | 关联是人类思考问题时经常运用的思想方法：通过一个事物联想到另外的事物。<br />能使人发生联想的原因是事物之间确实存在着某些联系 |
| 消息通信 | 这一原则要求对象之间只能通过消息进行通信，而不允许在对象之外直接地存取对象内部地属性。通过消息进行通信是由于封装原则而引起地。<br />在 OOA 中要求用消息连接表示出对象之间地动态联系。 |
| 粒度控制 | 一般来讲，人在面对一个复杂的问题域时，不可能在同一时刻既能纵观全局，又能洞察秋毫。因此需要控制自己的视野：<br />- 考虑全局时，注意其大的组成部分，暂时不考虑具体细节<br />- 考虑某部分细节时，则暂时撇开其余的部分<br />这就是粒度控制原则 |
| 行为分析 | 现实世界中事物的行为是复杂的，由大量的事物所构成的问题域中各种行为往往相互依赖、相互交织 |



##### 2.1.2 基本步骤

OOA 大致上遵循如下5个基本步骤：

1. **确定对象和类**：这里所说地对象是对数据及其处理方式的抽象，它反映了系统保存和处理现实世界中某些事物地信息的能力。类是多个对象的共同属性和方法集合的描述，它包括如何在一个类中建立一个新对象的描述
2. **确定结构**：结构是指问题域的复杂性和连接关系。类成员结构反映了泛化-特化关系，整体-部分结构反映整体和局部之间的关系
3. **确定主题**：主题是指事物的总体概貌和总体分析模型
4. **确定属性**：属性就是数据元素，可用来描述对象或分类结构的实例，可在图中给出，并在对象的存储中指定
5. **确定方法**：方法是在收到消息后必须进行的一些处理方法：方法要在图中定义，并在对象的存储中指定。对于每个对象和结构来说，那些用来增加、修改、删除和选择的方法本身都是隐含的(虽然它们是要在对象的存储中定义的，但并不在图上给出)，而有些则是显示的



#### 2.2 面向对象设计

面向对象设计方法（Object-Oriented Design，OOD）是 OOA 方法的延续，其**基本思想**包括**抽象**、**封装** 和 **可扩展性**，其中可扩展性主要通过继承和多态来实现。在 OOD 中，数据结构和在数据结构上定义的操作算法封装在一个对象之中。由于现实世界中的事物都可以抽象出对象的集合，所以 OOD 方法是一种更接近现实世界、更自然的系统设计方法。

类封装了信息和行为，是面向对象的重要组成部分，它是具有相同属性、方法、关系的对象集合的总称。在系统中，每个类都具有一定的职责，职责是指类所担任的任务。一个类可以有多种职责，设计得好的类一般至少有一种职责。在定义类时，将类的职责分解为类的属性和方法，其中属性用于封装数据，方法用于封装行为。设计类是 OOD 中最重要的组成部分，也是最复杂和最耗时的部分。

在 OOD 中，类可以分为3中类型：**实体类**、**控制类**、**边界类**

##### 2.2.1 实体类

实体类映射需求中的每个实体，是指实体类保存需要存储在永久存储体中的信息。实体类通常是永久性的，他们所具有的属性喝关系是长期需要的，有时甚至在系统的整个生存周期都需要。

实体类对用户来说是最有意义的类，通常采用业务领域术语命名，一般来说是一个名词，在用例模型向领域模型的转化中，一个参与者一般对应于实体类。通常可以从SRS中的那些与数据库表(需要持久存储)对应的名词着手来找寻实体类。通常情况下，实体类一定有属性，但不一定有操作。

##### 2.2.2 控制类

控制类是用于控制用例工作的类，一般是由动宾结构的短语转化来的名词。例如：用例“身份验证”可以对应一个控制类“身份验证器”，它提供了身份验证相关的所有操作。控制类用于对一个或几个用例所持有的控制行为进行建模，控制对象（控制类的实例）通常控制其他对象，因此他们的行为具有协调性。

控制类将用例的特有行为进行封装，控制对象的行为与特点用例的实现密切相关，当系统执行用例的时候，就产生了一个控制对象，控制对象经常在其对应的用例执行完毕后消亡。通常情况下，控制类没有属性，但一定有方法。

##### 2.2.3 边界类

边界类用于封装在用例内，外流动的信息或数据流。边界类位于系统与外界的交界处，包括所有窗体、报表、打印机和扫描仪等硬件的接口，以及其他系统的接口。要寻找和定义边界类，可以检查用例模型，每个参与者和用例交互至少要有一个边界类，边界类使参与者能与系统交互。边界类使一种用于系统外部环境与其内部运作之间的交互进行建模的类。常见的边界类有窗口、通信协议、打印机接口、传感器和终端等。实际上，在系统设计时，产生的报表都可以作为边界类来处理。

边界类用于系统接口与系统外部进行交互，边界对象将系统与其外部环境的变更分隔开，使这些变更不会对系统其他的部分造成影响。通常情况下，边界类可以既有属性也有方法。



#### 2.3 面向对象编程

面向对象程序设计（Object Oriented Programming，OOP）是一种计算机编程架构。OOP 的一条基本原则是计算机程序由单个能够起到子程序作用的单元或对象组合而成。OOP 达到了软件工程的3个主要目标：重用性、灵活性、扩展性。

OOP = 对象 + 类 + 继承 + 多态 + 消息，其中核心概念是类和对象。

面向对象程序设计方法是尽可能模拟人类的思维方式，使得软件的开发方法与过程尽可能接近人类认识世界、解决现实问题的方法和过程，也即使得描述问题的问题空间 与 问题解决方案空间在结构上尽可能一致，把客观世界中的实体抽象为问题域中对象。

面向对象程序设计以对象为核心，该方法认为程序由一系列对象组成。类是对现实世界的抽象，包括表示静态的数据和对数据的操作，对象是类的实例化。对象间通过消息传递相互通信，来模拟现实世界中不同实体间的联系。在面向对象的程序设计中，对象是组成程序的基本模块。

**OOP 的基本特点** 有：封装、继承、多态

1. **封装**：封装是指将一个计算机系统中的数据以及与这个数据相关的一切操作语言（即描述每一个对象的属性以及其行为的程序代码）组装到一起，一并封装在一个有机的实体中，把他们封装在一个“模块”中，也就是一个类中，为软件结构的相关部件所具有的模块性提供良好的基础。在面向对象技术的相关原理以及程序语言中，封装的最基本单位是对象，而使得软件结构的相关部件的实现“高内聚、低耦合”的 最佳状态 便是面向对象技术的封装性所需要实现的最基本的目标。对于用户来说，对象是如何对各种行为进行操作、运行、实现等细节是不需要刨根问底了解清楚的，用户只需通过封装外的通道对计算机进行相关方面的操作即可。
2. **继承**：继承是面向对象技术中的另外一个重要特点，其主要指的是两种或者两种以上的类之间的联系与区别。在面向对象技术中，继承是指一个对象针对于另一个对象的某些独有的特点、能力进行复制或者延续。如果按照继承源进行划分，则可以分为单继承与多继承；如果从继承中包含的内容进行划分，则继承可以分为4类：
   - 取代继承：一个对象在继承另一个对象的能力与特点之后将父对象进行取代
   - 包含继承：一个对象在另一个对象的能力与特点进行完全的继承之后，又继承了其他对象所包含的相应内容，结构导致这个对象所具有的能力与特点大于等于父对象，实现了对父对象的包含
   - 受限继承
   - 特化继承
3. **多态**：从宏观的角度来讲，多态是指在面向对象技术中，当不同的多个对象同时接收到同一个完全相同的消息之后，所表现出来的动作是各不相同的，具有多种形态；从微观的角度来讲，多态是指在一组对象的一个类中，面向对象技术可以使用相同的调用方式来对相同的函数名进行调用，即便这若干个具有相同函数名的函数所执行的动作是不同的



#### 2.4 数据持久化与数据库

在面向对象开发方法中，对象只能存在于内存中，而内存不能永久保存数据，如果要永久保存对象的状态，需要进行对象的持久化（Persistence），对象持久化是把内存中的对象保存到数据库或课永久保存的存储设备中。在多层软件设计和开发中，为了降低系统的耦合度，一般会引入持久层（Persistence Layer），即专注于实现数据持久化应用领域的某个特定系统的一个逻辑层面，将数据使用者和数据实体相关联，持久层的设计实现了数据处理层内部的业务逻辑和数据逻辑的解耦。

目前，关系数据库仍旧是使用最为广泛的数据库，如 DB2、Oracle、SQL Server等，因此将对象持久化到关系数据库中，需要进行对象/关系的映射（Object/Relation Mapping，ORM）。

随着对象持久化技术的发展，诞生了许多持久化框架，目前主流的持久化技术框架包括：Hibernate、iBatis、JDO等

1. **Hibernate** 是一个开放源代码的对象关系映射框架，它对 JDBC 进行了非常轻量级的对象封装，它将 POJO 与数据库表建立映射关系，是一个全自动的 ORM 框架，Hibernate 可以自动生成 SQL 语句，自动执行。
2. **iBatis** 提供 Java 对象到 SQL （面向参数和结果集）的映射实现，实际的数据库操作需要通过手动编写 SQL 实现，与 Hibernate 相比，iBatis 最大的特点就是小巧，上手快。如果不需要太多复杂的功能，iBatis 是既可满足要求又足够灵活的最简单的解决方案
3. JDO （Java Data Object）是 SUN 公司定制的描述对象持久化语义的标准 API，它是Java对象持久化的新规范。JDO 提供了透明的对象存储，对开发人员来说，存储数据对象完全不需要额外的代码。JDO 很灵活，因为它可以在任何数据底层上运行。JDBC 只能应用于关系型数据库，JDO 更通用，提供到任何数据底层的存储功能，包括关系型数据库、普通文件、XML 文件和对象数据库等，使得应用的可移植性更强。





## 四、软件测试



## 五、净室软件工程



## 六、基于构件的软件工程



## 七、软件项目管理

### 1 项目管理概述

软件项目管理和其他的项目管理相比有一定的特殊性。首先，软件是纯知识产品，其开发进度和质量很难估计和度量，生产效率也难以预测和保证。其次，软件系统的复杂性也导致了开发过程中各种风险的难以预见和控制。

为使软件项目开发获得成功，关键问题是必须对软件项目的工作范围、可能风险、需要资源、要实现的任务、经历的里程碑、花费工作量（成本）、进度安排等进行预先计划和执行。这种管理在技术工作开始之前就应该开始，在软件从概念到实现的过程中继续进行，当 软件工程过程最后结束时才终止。

软件项目管理是为了使软件项目能够按照预定的成本、进度、质量顺利完成，而对人员、产品、过程、项目 进行分析和管理的活动。



### 2 软件进度管理

- 进度：对执行活动和里程碑所制定的工作计划
- 进度管理：为了确保项目按期完成所需要的管理过程。

在软件进度管理过程中，一般包括：**活动定义**、**活动排序**、**活动资源估计**、**活动历时估计**、**制定进度计划**、**进度控制**。



#### 2.1 工作分解结构

工作分解结构（Work Breakdown Structure，WBS）就是把一个项目，按一定的原则分解成任务，任务再分解成一项项工作，再把一项项工作分配到每个人的日常活动中。即：项目 -> 任务 -> 工作 -> 日常活动。

工作分解结构以可交付成果为导向，对项目要素进行的分组，它归纳和定义了项目的整个工作范围，每下降一层代表对项目工作的更详细定义。

WBS 总是处于计划过程的中心，也是制订进度计划、资源需求、成本预算、风险管理计划、采购计划等重要基础。

![图片]({{ '/images/ruankao/framework/5/WBS示意图.png' | prepend: site.baseurl }})

WBS 树形结构中最底层的被称为工作包，是最低层次的可交付成果，它应当由唯一主体负责完成。

WBS 常见的**分解方式**包括：

- 按产品的物理结构分解
- 按产品或项目的功能分解
- 按照实施过程分解
- 按照项目的实施单位分解
- 按照项目的目标分解
- 按部分或职能进行分解

**任务分解的基本要求**：

1. WBS 的工作包是可控和可管理的，不能过于复杂
2. 任务分解也不能过细，一般原则 WBS 的树形结构不超过6层
3. 每个工作包要有一个交付成果
4. 每个任务必须有明确定义的完成标准
5. WBS 必须有利于责任分配



#### 2.2 任务活动图

经过工作分解之后，会得到一组活动任务，这时需要对每个活动进行定义，并确定活动之间的关系。

活动定义是指确定完成项目的各个交付成果所必须进行的各项具体活动，需要明确每个活动的前驱、持续时间、必须完成日期、里程碑或交付成果。

- **前驱**：该活动开始之前必须发生的事件或事件集
- **持续时间**：完成该活动的时间长度（一般单位为天或周）
- **必须完成日期**：该活动必须完成的具体日期
- **里程碑**：指的是判断该活动完成的一组条件

每个活动在明确了前驱、必须完成日期等内容后，就确定了活动之间的相互关系，也就是活动执行的前后顺序。根据活动顺序就可以得到对应的任务活动图。**任务活动图是项目进度管理、项目成本管理等一系列项目管理活动的基础**。

在项目管理中，目前通常采用**甘特图**等方式来展示和管理项目活动。



### 3 软件配置管理

软件配置管理（Software Configuration Management，SCM）是一种 **标识**、**组织** 和 **控制修改** 的技术。

SCM活动的目标就是为了**标识变更**、**控制变更**、**确保变更正确实现** 并向其他有关人员**报告变更**。

软件配置管理核心内容包括 **版本控制** 和 **变更控制**。

1. **版本控制**：是指对软件开发过程中各种程序代码、配置文件 及 说明文档 等文件变更的管理，是软件配置管理的核心思想之一。
   - 版本控制最主要的功能就是**追踪文件的变更**。它将什么时候、什么人更改了文件的什么内容等信息忠实地记录下来。
   - 版本控制另一个重要功能是并行开发。可以有效地解决版本的同步以及不同开发者之间的开发通信问题，提高协同开发的效率
2. **变更控制**：变更控制的目的不是控制变更的发生，而是对变更进行管理，确保变更有序进行。项目中引起变更的因素有两个：
   - 来自外部的变更要求，如客户修改工作范围或需求等
   - 开发过程内部的变更要求，如为了解决测试中发现的一些错误而修改代码或设计



### 4 软件质量管理

软件质量是软件符合明确地叙述的功能和性能需求、文档中明确描述的开发标准以及所有专业开发的软件都应具有的隐含特征的程度。

从管理角度出发，可以将影响软件质量的因素划分为三组，分别反映用户在使用软件产品时的三种不同倾向和观点。分别是：**产品运行**、**产品修改**、**产品转移**。

1. 产品运行
   - 正确性：它能按我的需要工作吗
   - 健壮性：对意外环境它能适当的响应吗
   - 效率：完成预定功能时它需要的计算机资源多吗
   - 完整性：它是安全的吗
   - 可用性：我能使用它吗
   - 风险：能按预定计划完成它吗
2. 产品修改
   - 可理解性：能理解它吗
   - 可维修性：能修复它吗
   - 灵活性：能改变它吗
   - 可测试性：能测试它吗
3. 产品转移
   - 可移植性：能在另一台机器上使用它吗
   - 可再用性：能再用它的某些部分吗
   - 互运行性：能把它和另一个系统结合吗



#### 4.1 软件质量保证

软件质量保证（Software Quality Assurance，SQA）是建立一套有计划，有系统的方法，来向管理层保证拟定出的标准、步骤、实践和方法能够正确地被所有项目所采用。

软件质量保证的 **目的** 是使软件过程对于管理人员来说是可见的。它通过对软件产品和活动进行评审和审计来验证软件是合乎标准的。软件质量保证组在项目开始时就一起参与建立计划、标准和过程。

质量保证的主要目标是：

1. 事前预防工作。例如，着重于缺陷预防而不是缺陷检查
2. 尽量在刚刚引入缺陷时即将其捕获，而不是让缺陷扩散到下一个阶段
3. 作用于过程而不是最终产品，因此它有可能会带来广泛的影响与巨大的收益
4. 贯穿于所有的活动之中，而不是只集中于一点

软件质量保证的 **目标** 是以独立审查的方式，从第三方的角度监控软件开发任务的执行，就软件项目是否正确遵循已制订的计划、标准和规程给开发人员和管理层提供反映产品和过程质量的信息和数据，提高项目透明度，同时辅助软件工程取得高质量的软件产品。

软装质量保证的主要 **作用** 是给管理者提供预定义的软件过程的保证，因此 SQA 组织要保证如下内容的实现：

- 选定的开发方法被采用
- 选定的标准和规程得到采用和遵循
- 进行独立的审查
- 偏离标准和规程的问题得到及时的反映和处理
- 项目定义的每个软件任务得到实际的执行

软件质量保证的主要 **任务** 是：

1. **SQA 审计与评审**：包括对软件工作产品、软件工具、设备 的审计，评价这几项内容是否符合组织规定的标准。保证软件工作组的活动与预定的软件过程一致，确保软件过程在软件产品的生产中得到遵循
2. **SQA 报告**：SQA 人员应记录工作的结果，并写入到报告之中，发布给相关的人员。SQA 报告的发布原则：
   - SQA 和高级管理者之间应有直接沟通的渠道
   - SQA 报告必须发布给软件工程组，但不必发布给项目管理人员
   - 在可能的情况下向关心软件质量的人发布 SQA 报告
3. **处理不符合问题**：这是 SQA 的一个重要的任务，SQA 人员要对工作过程中发现的问题进行处理，及时向有关人员及高级管理者反映



#### 4.2 软件质量认证

质量认证用来检验整个企业的质量水平，注重软件企业的整体资质，全面考察软件企业的整体质量体系，检验该企业是否具有设计、开发和生产符合质量要求的软件的能力。

目前国内软件企业主要采用的是 ISO 9000 和 能力成熟度模型（Capability Maturity Model，CMM）。

##### 4.2.1 ISO 9000

ISO 9000 标准是国际标准化组织(ISO)在1994年提出的概念，是指由 ISO/Tc176 制定的国际标准。ISO 9001用于证实组织具有提供满足顾客要求和适用法规要求的产品的能力，目的在于增进顾客满意。

ISO 9000 不是指一个标准，而是一组标准的统称。软件企业经常采用的是 ISO 9001:1994 《质量体系——设计、开发、生产、安装的品质保证模式》

##### 4.2.2 CMM

CMM 是由美国卡内基梅隆大学软件工程研究所 1987 年研制成功的，是软件生产过程标准和软件企业成熟度等级认证标准，我国软件企业大多采用 CMM 认证



### 5 软件风险管理

在进行软件项目风险管理时，要辨识风险，评估它们出现的概率及产生的影响，然后建立一个规划来管理风险。

风险管理的主要目标是预防风险。

美国 Boehm 的软件风险管理体系，把风险管理活动分成两大阶段：

- 风险评估：风险辨识、风险分析、风险排序
- 风险控制：风险管理计划、风险处理、风险监督

美国 Charette 的风险分析和管理体系，把风险分成两大阶段：

- 分析：辨识、评估、评价
- 管理：计划、控制、监督

美国卡内基梅隆大学软件研究所的 CMU-SEI 风险管理体系,是基于实践的全面风险管理体系，并将软件需求方作为软件风险管理的要素，包括:

- SRE
- CRM（Continuous Risk Management）
- TRM（Team Risk Management）
