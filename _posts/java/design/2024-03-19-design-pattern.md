---
layout: post
title:  Java设计模式
date:   2024-03-19 00:00:00 +0800
categories: 系统设计
tag: 系统设计
author: YangLe
---




设计模式是在软件设计中反复出现的问题的通用解决方案。它们是经过多次验证和应用的指导原则，旨在帮助软件开发人员解决特定类型的问题，提高代码的可维护性、可扩展性和重用性。

设计模式是一种抽象化的思维方式，可以帮助开发人员更好地组织和设计他们的代码。它们提供了一种通用的框架，可以用于解决各种不同的软件设计问题。设计模式不是完整的代码，而是一种描述问题和解决方案之间关系的模板。

设计模式并不是一成不变的法则，而是根据不同的问题和情境来决定是否使用以及如何使用。了解和应用设计模式可以帮助开发人员更好地组织代码，提高代码的可读性和可维护性，同时也有助于促进团队之间的合作和沟通。



### 设计模式的分类

1. **创建型模式（Creational）**：**关注对象的实例化过程**，包括了如何实例化对象、隐藏对象的创建细节等。常见的创建型模式有单例模式、工厂模式、抽象工厂模式等。
2. **结构型模式（Structural）**：**关注对象之间的组合方式**，以达到构建更大结构的目标。这些模式帮助你定义对象之间的关系，从而实现更大的结构。常见的结构型模式有适配器模式、装饰器模式、代理模式等。
3. **行为型模式（Behavioral）**：**关注对象之间的通信方式**，以及如何合作共同完成任务。这些模式涉及到对象之间的交互、责任分配等。常见的行为型模式有观察者模式、策略模式、命令模式等。



### 设计模式的基本要素

1. **模式名称**：每个设计模式都有一个简洁的名称，用于描述问题、解决方案和效果。这个名称有助于在交流中快速指代模式。
2. **问题**：描述了在什么情况下应该考虑使用特定的设计模式。问题部分阐述了该模式试图解决的具体设计难题。
3. **解决方案**：解决方案部分提供了一个详细的设计指南，描述了如何组织类、对象以及它们之间的关系，以解决特定问题。这包括了每个角色的职责、协作方式等。
4. **效果**：描述了模式应用的效果及使用模式应权衡的问题。



### 设计模式概览

#### 创建型

| 名称                            | 范围 | 描述                                                         |
| ------------------------------- | ---- | ------------------------------------------------------------ |
| 工厂方法模式 (Factory Method)   | 类   | 定义一个用于创建对象的接口，让子类决定将哪一个类实例化       |
| 抽象工厂模式 (Abstract Factory) | 对象 | 提供一个创建一系列相关或互相依赖对象的接口，而无需指定它们具体的类 |
| 建造者模式 (Builder)            | 对象 | 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示 |
| 原型模式 (Prototype)            | 对象 | 用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象 |
| 单例模式 (Singleton)            | 对象 | 保证一个类仅有一个实例，并提供一个访问它的全局访问点         |



#### 结构型

| 名称                 | 范围    | 描述                                                         |
| -------------------- | ------- | ------------------------------------------------------------ |
| 适配器模式 (Adapter) | 类/对象 | 将一个类的接口转换成客户希望的另一个接口<br />Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作 |
| 桥接模式 (Bridge)    | 对象    | 将抽象部分与它的实现部分分离，使它们都可以独立的变化         |
| 组合模式 (Composite) | 对象    | 将对象组合成树形结构以表示 部分-整体 的层次结构<br />Composite使得客户对单个对象和复合对象的使用具有一致性 |
| 装饰模式 (Decorator) | 对象    | 动态的给一个对象添加一些额外的职责，就拓展功能而言，Decorator模式比生成子类方式更为灵活 |
| 外观模式 (Facade)    | 对象    | 为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用 |
| 享元模式 (Flyweight) | 对象    | 运用共享技术有效的支持大量细粒度的对象                       |
| 代理模式 (Proxy)     | 对象    | 为其他对象提供一个代理以控制对这个对象的访问                 |



#### 行为型

| 名称                                 | 范围 | 描述                                                         |
| ------------------------------------ | ---- | ------------------------------------------------------------ |
| 解释器模式 (Interpreter)             | 类   | 给定一个语音，定义他的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子 |
| 模板方法模式 (Template Method)       | 类   | 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。<br />Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤 |
| 责任链模式 (Chain of Responsibility) | 对象 | 为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它 |
| 命令模式 (Command)                   | 对象 | 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可取消的操作 |
| 迭代器模式 (Iterator)                | 对象 | 提供一种方法顺序访问一个聚合对象中各元素，而又不需要暴露该对象的内部表示 |
| 中介者模式 (Mediator)                | 对象 | 用一个中介对象来封装一系列的对象交互，中介者使得各对象不需要显式地互相引用，从而使其耦合松散，而且可以独立的改变他们之间的交互 |
| 备忘录模式 (Memento)                 | 对象 | 在不破坏封装性的前提下，捕获一个对象的内部状态               |
| 观察者模式 (Observer)                | 对象 | 定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新 |
| 状态模式 (State)                     | 对象 | 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类 |
| 策略模式 (Strategy)                  | 对象 | 定义一系列的算法，把他们一个个封装起来，并且使它们可互相替换。本模式使得算法的变化可独立于使用它的客户 |
| 访问者模式 (Visitor)                 | 对象 | 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作 |



### 设计模式间的关系

![图片]({{ '/images/java/设计模式.png' | prepend: site.baseurl }})



https://zhuanlan.zhihu.com/p/651451595