---
layout: post
title: redis 简介
date:   2024-08-08
categories: 数据库
tag: 数据库
author: YangLe
excerpt_image: /images/database/redis/redis数据结构.png
---



## 一、Redis 介绍

Redis 全称 Remote Dictionary Server（远程字典服务），是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库，并提供多种语言的API。

Redis的数据是存在内存中的。它的读写速度非常快，每秒可以处理超过10万次读写操作。因此 Redis 被广泛应用于缓存，也经常用来做分布式锁。

Redis 支持事务、持久化、LUA脚本、LRU驱动事件、多种集群方案。



## 二、数据结构类型

**基本类型**：

1. **String** 字符串
   - **简介说明**：最基础的数据结构类型，二进制安全的，可以存储图片或序列化的对象，最大存储512M
   - **应用场景**：共享session、分布式锁、计数器、限流
2. **Hash** 哈希
   - **简介说明**：它的值本身也是一个键值对（k-v）结构
   - **内部编码**：ziplist（压缩列表）、hashtable（哈希表）
   - **应用场景**：缓存用户信息等
   - **注意事项**：使用 hgetall 时，如果哈希元素比较多，可能导致Redis阻塞，可以使用hscan。如果只是获取部分 field，建议使用 hmget。
3. **List** 列表
   - **简介说明**：用来存储多个有序的字符串，一个列表最多可以存储 4294967295 （2^32 - 1）个元素
   - **内部编码**：ziplist（压缩列表）、linkedlist（链表）
   - **应用场景**：消息队列、文章列表
   - **使用组合**：
     - lpush + lpop = Stack (栈)
     - lpush + rpop = Queue (队列)
     - lpush + ltrim = Capped Collection (有限集合)
     - lpush + brpop = Message Queue (消息队列)
4. **Set** 集合
   - **简介说明**：用来保存多个字符串元素，但是不允许重复元素
   - **内部编码**：intset（整数集合）、hashtable（哈希表）
   - **应用场景**：用户标签、生成随机数抽奖、社交需求
   - **注意事项**：smembers、lrange、hgetall 属于比较重的命令、如果元素过多存在阻塞 redis 的可能性，可以使用 sscan 来完成
5. **Zset** 有序集合
   - **简介说明**：已排序的字符串集合，同时元素不能重复
   - **内部编码**：ziplist（压缩列表）、skiplist（跳跃表）
   - **应用场景**：排行榜、社交需求（用户点赞）



**特殊数据结构类型**：

- **Geo**：redis 3.2 推出的，地理位置定位，用于存储地理位置信息，并对存储的信息进行操作
- **HyperLogLog**：用来做基数统计算法的数据结构，如统计网站的UV
- **Bitmap**：用一个比特位来映射某个元素的状态，它的底层是基于字符串类型实现的，可以把 bitmaps 看着一个以比特位为单位的数组



## 三、操作命令

### 3.1 keys

基本语法：COMMAND key_name

| 序号 | 命令                                      | 描述                                                         | 可用版本 | 返回值                                                       |
| ---- | ----------------------------------------- | ------------------------------------------------------------ | -------- | ------------------------------------------------------------ |
| 1    | DEL key                                   | 用于删除已存在的键，不存在的key会被忽略                      | >=1.0.0  | 被删除key的数量                                              |
| 2    | DUMP key                                  | 序列化给定key，并返回被序列化的值                            | >=2.6.0  | key存在返回序列化后的值<br />不存在返回 nil                  |
| 3    | EXISTS key                                | 检查key是否存在                                              | >=1.0.0  | 存在返回1，不存在返回0                                       |
| 4    | EXPIRE key seconds                        | 设置key的过期时间，过期后不可再用，单位以秒计                | >=1.0.0  | 成功返回1，失败返回0                                         |
| 5    | EXPIREAT key timestamp                    | 以UNIX时间戳格式设置key过期时间                              | >=1.0.0  | 成功返回1，失败返回0                                         |
| 6    | PEXPIRE key milliseconds                  | 以毫秒为单位设置key过期时间                                  | >=2.6.0  | 成功返回1，失败返回0                                         |
| 7    | PEXPIREAT key millseconds-timestamp       | 以UNIX时间戳格式设置key过期时间（毫秒级）                    | >=1.0.0  | 成功返回1，失败返回0                                         |
| 8    | KEYS pattern                              | 查询所有符合给的pattern的key                                 | \>=1.0.0 | 返回key列表(Array)                                           |
| 9    | MOVE key db                               | 将当前key移动到给定的数据库db中                              | \>=1.0.0 | 成功返回1，失败返回0                                         |
| 10   | PERSIST key                               | 移除key过期时间，使其永不过期                                | >=2.2.0  | 成功返回1，失败返回0                                         |
| 11   | PTTL key                                  | 以毫秒为单位返回key的剩余过期时间                            | >=2.6.0  | key不存在 -2<br />存在但没有过期时间 -1<br />其他返回剩余生存时间 |
| 12   | TTL key                                   | 以秒为单位返回key剩余过期时间                                | \>=1.0.0 | 同上                                                         |
| 13   | RANDOMKEY                                 | 从当前数据库中随机返回一个key                                | \>=1.0.0 | 数据库不为空时，返回一个key<br />为空时，返回 nil            |
| 14   | RENAME key newkey                         | 用于修改key的名称，新key已经存在时会覆盖                     | \>=1.0.0 | 改名成功时提升OK，失败时返回一个错误                         |
| 15   | RENAMENX key newkey                       | 新key不存在时，修改key的名称                                 | \>=1.0.0 | 成功返回1，新key已经存在时返回0                              |
| 16   | SCAN cursor [MATCH pattern] [COUNT count] | cursor 游标，pattern 匹配模式，count 每次返回key的数量，默认10 | >=2.8.0  | 数组列表                                                     |
| 17   | TYPE key                                  | 返回key所存储的值的类型                                      | \>=1.0.0 | none (key不存在)<br />string (字符串)<br />list (列表)<br />set (集合)<br />zset (有序集)<br />hash (哈希表) |



### 3.2 String

| 序号 | 命令                             | 描述                                                         | 可用版本 | 返回值                                                    |
| ---- | :------------------------------- | ------------------------------------------------------------ | -------- | --------------------------------------------------------- |
| 1    | SET key value                    | 给指定key设置值，如果key已存储其他值，直接覆盖，且无视类型   | >=1.0.0  | OK                                                        |
| 2    | GET key                          | 获取key的值                                                  | >=1.0.0  | 返回key的值<br />不存在返回 nil<br />非字符串类型返回错误 |
| 3    | GETRANGE key start end           | 获取截取后的key的值                                          | >=2.4.0  | 截取得到的子字符串                                        |
| 4    | GETSET key value                 | 设置key的值，并返回旧值                                      | >=1.0.0  | 返回key旧值<br />不存在返回nil<br />非字符串类型返回错误  |
| 5    | GETBIT key offset                | 获取指定偏移量上的位                                         | >=2.2.0  | 字符串指定偏移量上的位<br />不存在或超出时返回0           |
| 6    | MGET key1 [key2...]              | 返回多个key的值                                              | >=1.0.0  | 包含所有给定 key 的值的列表                               |
| 7    | SETBIT key offset value          | 对key所存储的字符串值，设置或清除指定偏移量上的位(bit)       | >=2.2.0  | 指定偏移量原理存储的位                                    |
| 8    | SETEX key seconds value          | 给指定key设置值和过期时间；如果key已经存在，替换旧值         | >=2.0.0  | 设置成功时返回OK                                          |
| 9    | SETNX key value                  | 指定key不存在时，为key设置值                                 | >=1.0.0  | 成功返回1，失败返回0                                      |
| 10   | SETRANGE key offset value        | 用指定的字符串覆盖给定 key 所储存的字符串值，覆盖的位置从偏移量 offset 开始 | >=2.2.0  | 被修改后的字符串长度                                      |
| 11   | STRLEN key                       | 获取字符串长度                                               | >=2.2.0  | 字符串长度<br />不存在时返回0                             |
| 12   | MSET key value [key value ...]   | 同时设置1个或多个 k-v 对                                     | >=1.0.1  | OK                                                        |
| 13   | MSETNX key value [key value ...] | 所有key都不存在时，同时设置一个或多个K-V对。操作具有原子性，同时成功或失败 | >=1.0.1  | 都成功时返回1<br />失败返回0                              |
| 14   | PSETEX key millseconds value     | 以毫秒为单位设置key的生存时间                                | >=2.6.0  | 成功时返回OK                                              |
| 15   | INCR key                         | 将key中存储的数字值加1，key不存在会先初始化成0再加1<br />本操作的值限制在 64 位(bit)有符号数字表示之内 | >=1.0.0  | incr后的值<br />非数字值时返回错误                        |
| 16   | INCRBY key increment             | 将key中存储数字加上指定增量，key不存在时会先初始化成0再加<br />本操作的值限制在 64 位(bit)有符号数字表示之内 | >=1.0.0  | incr后的值<br />非数字值时返回错误                        |
| 17   | INCRBYFLOAT key increment        | 将key中所存储的值加上指定浮点值，key不存在时先初始化成0再加  | >=2.6.0  | incr后的值<br />非数字值时返回错误                        |
| 18   | DECR key                         | 将key中数字减一，key不存在时先初始化成0再减1<br />本操作的值限制在 64 位(bit)有符号数字表示之内 | >=1.0.0  | 执行命令后的值<br />非数字值时返回错误                    |
| 19   | DECRBY key decrement             | 将key所存储的值减去指定的减量值，key不存在时先初始化成0再减<br />本操作的值限制在 64 位(bit)有符号数字表示之内 |          |                                                           |
| 20   | APPEND key value                 | 如果key存在，将value追加到原值末尾；如果key不存在，将value设置为值 | >=2.0.0  | 追加指定值之后， key 中字符串的长度                       |



### 3.3 Hash

hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。

每个 hash 可以存储 2^32 - 1 键值对（40多亿）

| 序号 | 命令                                           | 描述                                                         | 可用版本 | 返回值                                  |
| ---- | ---------------------------------------------- | ------------------------------------------------------------ | -------- | --------------------------------------- |
| 1    | HEDL key field1 [field2]                       | 删除hash表中1个或多个字段，不存在的忽略                      | >=2.0.0  | 被成功删除的数量                        |
| 2    | HEXISTS key field                              | 查看哈希表中指定字段是否存在                                 | >=2.0.0  | 存在返回1，不存在返回0                  |
| 3    | HGET key field                                 | 查询哈希表中指定字段的值                                     | >=2.0.0  | 存在返回值，不存在返回nil               |
| 4    | HGETALL key                                    | 返回所有的字段和值                                           | >=2.0.0  | 以列表形式返回字段和字段值              |
| 5    | HINCRBY key field increment                    | 对哈希表中字段值进行加法操作，增量值可以为负，不存在就创建一个值0<br />本操作的值被限制在 64 位(bit)有符号数字表示之内 | >=2.0.0  | 执行命令后的值<br />值非数字返回错误    |
| 6    | HINCRBYFLOAT key field increment               | 对哈希表中的字段值加上指定浮点数，不存在时先初始化一个0      | >=2.6.0  | 执行命令后的值<br />值非数字返回错误    |
| 7    | HKEYS key                                      | 获取哈希表中这个key下所有的field                             | >=2.0.0  | field列表                               |
| 8    | HLEN key                                       | 获取哈希表中这个key下所有field数量                           | >=2.0.0  | field数量                               |
| 9    | HMGET key field1 [field2]                      | 获取哈希表中一个或多个字段值，不存在时返回nil                | >=2.0.0  | 按顺序返回字段值                        |
| 10   | HMSET key field1 value1 [field2 value2]        | 同时将多个 f-v 对设置到哈希表中，不存在就创建新的，存在时覆盖 | >=2.0.0  | OK                                      |
| 11   | HSET key field value                           | 为哈希表字段赋值，不存在创建新的，存在时覆盖                 | >=2.0.0  | 新建时返回1，覆盖时返回0                |
| 12   | HSETNX key field value                         | 为哈希表中不存在的字段赋值                                   | >=2.0.0  | 设置成功返回1，失败返回0                |
| 13   | HVALS key                                      | 获取哈希表所有的值                                           | >=2.0.0  | 包含所有值的列表                        |
| 14   | HSCAN key cursor [MATCH pattern] [COUNT count] | 迭代哈希表中的键值对<br />cursor 游标，pattern 匹配模式，count 返回数量 默认10 | >=2.8.0  | 返回的每个元素都是一个元组(field-value) |



### 3.4 List

字符串列表，按照插入顺序排序，可以在头部(左边)或尾部(右边) 添加一个元素、

一个列表最多可以包含2^32-1 个元素 （4294967295）

| 序号 | 命令                                  | 描述                                                         | 可用版本 | 返回值                                              |
| ---- | ------------------------------------- | ------------------------------------------------------------ | -------- | --------------------------------------------------- |
| 1    | BLPOP key1 [key2] timeout             | 移出并获取第一个元素，列表没有元素时会阻塞等待到超时或发现可弹出元素为止 | >=2.0.0  | 空时返回nil 和等待时长，非空时返回元素key和值       |
| 2    | BRPOP key1 [key2] timeout             | 移出并获取列表最后一个元素，如果列表没有元素会阻塞等到超时或发现可弹出元素为止 | >=2.0.0  | 空时返回nil 和等待时长，非空时返回元素key和值       |
| 3    | BRPOPLPUSH source destination timeout | 移出并获取最后一个元素，并插入到另一个列表头部，如果列表没有元素会等到超时或发现可弹出元素为止 | >=2.0.0  | 返回元素和等待时长                                  |
| 4    | LINDEX key index                      | 通过索引获取元素，-1表示最后一个，-2表示倒数第二个           | >=1.0.0  | 返回指定的元素，不存在返回 nil                      |
| 5    | LINSERT key BEFORE\|AFTER pivot value | 在指定元素(pivot)前或后插入元素（value），不存在时不插入     | >=1.0.0  | 成功返回列表长度，没找到pivot返回-1，key不存在返回0 |
| 6    | LLEN key                              | 获取列表长度                                                 | >=1.0.0  | key不存在返回0，非列表返回错误，正常返回列表长度    |
| 7    | LPOP key                              | 移除并返回列表的第一个元素                                   | >=1.0.0  | 不存在时返回nil，存在返回第一个元素                 |
| 8    | LPUSH key value1 [value2]             | 将一个或多个值插入到列表头部                                 | >=1.0.0  | 成功返回列表长度，非列表类型时返回错误              |
| 9    | LPUSHX key value                      | 将一个值插入到列表头部，列表不存在时忽略                     | >=2.2.0  | 列表长度                                            |
| 10   | LRANGE key start stop                 | 返回指定区间内的元素。0 第一个，1 第二个，-1 最后一个，-2 倒数第二个 | >=1.0.0  | 一个列表，包含指定元素                              |
| 11   | LREM key count value                  | 移除列表中于value相等的元素。count >0 从表头开始移除count个；count<0从表尾开始移除count个；count=0 移除所有等于value的 | >=1.0.0  | 被移除元素的数量                                    |
| 12   | LSET key index value                  | 通过索引设置元素值，索引超出范围时返回错误                   | >=1.0.0  | 成功返回OK，失败返回错误                            |
| 13   | LTRIM key start stop                  | 对列表进行修剪，只保留指定区间内的元素                       |          | 成功时返回OK                                        |
| 14   | RPOP key                              | 移除列表最后一个元素，返回值为该元素                         | >=1.0.0  | 被移除的元素                                        |
| 15   | RPOPLPUSH source destination          | 移除最后一个元素，并将该元素添加到另一个列表返回             | >=1.0.0  | 被弹出的元素                                        |
| 16   | RPUSH key value1 [value2]             | 将一个或多个值插入到列表尾部                                 | >=1.0.0  | 操作后列表长度                                      |
| 17   | RPUSHX key value                      | 将值插入到已存在的列表尾部，列表不存在就忽略                 | >=2.2.0  | 操作后列表长度                                      |



### 3.5 Set

Set 是 String 类型的无序集合，集合成员是唯一的。

集合是通过哈希表实现的，添加、删除、查找的复杂度都是O(1)。集合中最大成员数为 2^32 - 1 个

| 序号 | 命令                                           | 描述                                                         | 可用版本 | 返回值                 |
| ---- | ---------------------------------------------- | ------------------------------------------------------------ | -------- | ---------------------- |
| 1    | SADD key member1 [member2]                     | 将一个或多个元素加入到集合中，已存在的忽略                   | \>=1.0.0 | 新添加的个数           |
| 2    | SCARD key                                      | 获取集合中元素的数量                                         | \>=1.0.0 | 元素个数               |
| 3    | SDIFF key1 [key2]                              | 获取key1集合中独有的元素                                     | \>=1.0.0 | 结果集的元素列表       |
| 4    | SDIFFSTORE destination key1 [key2]             | 获取key1集合中独有的元素并存储到 destination中               | \>=1.0.0 | 结果集的元素个数       |
| 5    | SINTER key1 [key2]                             | 获取给定集合的交集                                           | \>=1.0.0 | 交集成员列表           |
| 6    | SINTERSTORE destination key1 [key2]            | 获取给定集合的交集，并存储到destination中                    | \>=1.0.0 | 交集成员个数           |
| 7    | SISMEMBER key member                           | 判断集合中是否包含该成员                                     | \>=1.0.0 | 包括返回1，否则返回0   |
| 8    | SMEMBERS key                                   | 返回集合所有成员                                             | \>=1.0.0 | 所有成员组成的列表     |
| 9    | SMOVE source destination member                | 将指定成员从source移动到destination中                        | \>=1.0.0 | 成功返回1，失败返回0   |
| 10   | SPOP key [count]                               | 移除集合中一个或多个元素，并返回这些元素                     | \>=1.0.0 | 被移除的元素           |
| 11   | SRANDMEMBER key [count]                        | 返回集合中随机元素<br />count是正数，返回count个不同元素，如果大于集合数量，返回所有元素<br />count是负数，返回count绝对值个元素，并且可能会重复 | \>=1.0.0 | 返回随机元素           |
| 12   | SREM key member1 [member2]                     | 移除集合中的一个或多个元素，不存在的元素忽略                 | \>=1.0.0 | 被成功移除的元素的数量 |
| 13   | SUNION key1 [key2]                             | 获取给定集合的并集                                           | \>=1.0.0 | 并集成员列表           |
| 14   | SUNIONSTORE destination key1 [key2]            | 将给定集合的并集保存到destination中                          | \>=1.0.0 | 结果集元素个数         |
| 15   | SSCAN key cursor [MATCH pattern] [COUNT count] | 迭代返回集合中元素<br />cursor 游标，pattern 匹配模式，count 返回个数(默认10) | \>=2.8.0 | 数组列表               |



### 3.6 sorted set

有序集合 也是string类型元素的集合，且元素不能重复，每个元素都会关联一个double类型的分数，并且通过分数从小到大排序。

集合是通过哈希表实现的，添加、删除、查找的复杂度都是O(1)。集合中最大成员数为 2^32 - 1 个

| 序号 | 命令                                                         | 描述                                                         | 可用版本 | 返回值               |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------- | -------------------- |
| 1    | ZADD key score1 member1 [score2 member2]                     | 将一个或多个成员及其分数添加到有序集合中                     | \>=1.2.0 | 成功新增的成员数量   |
| 2    | ZCARD key                                                    | 计算集合中元素个数                                           | \>=1.2.0 | 数量                 |
| 3    | ZCOUNT key min max                                           | 获取分数在min和max之间的成员数量                             | \>=2.0.0 | 数量                 |
| 4    | ZINCRBY key increment member                                 | 对集合中指定成员的分数加上increment                          | \>=1.2.0 | 成员新分数           |
| 5    | ZINTERSTORE destination numkeys key [key ...] [WEIGHTS ...] [AGGREGATE sum\|min\|max] | 计算多个集合交集<br />destination 结果集名称<br />numkeys 计算的集合数量<br />key 计算的集合名称<br />WEIGHTS 每个集合权重<br />AGGREGATE 聚合方式 | \>=2.0.0 | 目标结果数量         |
| 6    | ZLEXCOUNT key min max                                        | 指定区间内成员数量                                           | \>=2.8.9 | 数量                 |
| 7    | ZRANGE key start stop [WITHSCORES]                           | 获取指定区间内成员数量<br />0 第一个，1 第二个<br />-1 最后一个，-2 倒数第二个 | \>=1.2.0 | 成员列表             |
| 8    | ZRANGEBYLEX key min max [LIMIT offset count]                 | 获取指定字典序范围内的成员<br />min max 字典序边界值，- 负无穷大，+ 正无穷大，也可是具体字符串 | \>=2.8.9 | 成员列表             |
| 9    | ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT]               | 获取指定分数区间的成员列表，按分数从小到大排序<br />默认使用闭区间，也可使用 ( 变成开区间 | \>=1.0.5 | 成员列表             |
| 10   | ZRANK key [member]                                           | 显示指定成员排名，也可按顺序返回                             | \>=2.0.0 | 成员排名             |
| 11   | ZREM key member [member ...]                                 | 移除一个或多个成员                                           | \>=1.2.0 | 移除数量             |
| 12   | ZREMRANGEBYLEX key min max                                   | 移除指定字典区间的成员                                       | \>=2.8.9 | 移除数量             |
| 13   | ZREMRANGEBYRANK key start stop                               | 移除指定排名区间的成员                                       | \>=2.0.0 | 移除数量             |
| 14   | ZREMRANGEBYSCORE key min max                                 | 移除指定分数区间的成员                                       | \>=1.2.0 | 移除数量             |
| 15   | ZREVRANGE key start stop [WITHSCORES]                        | 获取指定区间内的成员                                         | \>=1.2.0 | 成员列表             |
| 16   | ZREVRANGEBYSCORE key max min [WITHSCORES]                    | 获取指定分数区间内的成员，分数从大到小排列                   | \>=2.2.0 | 成员列表             |
| 17   | ZREVRANK key member                                          | 获取成员排名                                                 | \>=2.2.0 | 成员排名             |
| 18   | ZSCORE key member                                            | 获取集合中成员的分数                                         | \>=1.2.0 | 分数值               |
| 19   | ZUNIONSTORE destination numkeys key [key ...]                | 计算numkeys个集合的并集，结果保存到destination中             | \>=2.0.0 | 结果集成员个数       |
| 20   | ZSCAN key cursor [MATCH pattern] [COUNT count]               | 迭代有序集合中的元素                                         | \>=2.8.0 | 成员和分值组成的集合 |



### 3.7 HyperLogLog

HyperLogLog 是用来做基数统计的算法，数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。

| 序号 | 命令                                    | 描述                 | 可用版本  | 返回值       |
| ---- | --------------------------------------- | -------------------- | --------- | ------------ |
| 1    | PFADD key element1 [element2]           | 将元素加入到数据集中 | \>= 2.8.9 | 成功1，失败0 |
| 2    | PFCOUNT key1 [key2]                     | 获取数据集基数估算值 | \>= 2.8.9 | 整数         |
| 3    | PFMERGE destkey sourcekey1 [sourcekey2] | 合并多个数据集       | \>= 2.8.9 | OK           |



### 3.8 GEO

主要用于存储地理位置信息，并对存储的信息进行操作

| 序号 | 命令                                                         | 描述                                                         | 可用版本 | 返回值                      |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------- | --------------------------- |
| 1    | GEOADD key lon lat member [lon2 lat2 member2]                | 将一个或多个位置信息添加到指定key中                          | >=3.2.0  | 添加个数                    |
| 2    | GEOPOS key member [member]                                   | 获取指定member的位置信息                                     | >=3.2.0  | 位置信息列表，不存在返回nil |
| 3    | GEODIST key member1 member2 [m\|km\|ft\|mi]                  | 计算两个位置之间距离。<br />m 米(默认单位)，km 千米，mi 英里，ft英尺 | >=3.2.0  | 返回距离                    |
| 4    | GEORADIUS key longitude latitude radius m\|km\|ft\|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC\|DESC] [STORE key] [STOREDIST key] | 以给定经纬度为中心，返回距离内的所有元素                     | >=3.2.0  | 元素信息                    |
| 5    | GEORADIUSBYMEMBER key member radius m\|km\|ft\|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC\|DESC] [STORE key] [STOREDIST key] | 以给定元素为中心，返回距离内所有元素                         | >=3.2.0  | 元素信息                    |
| 6    | GEOHASH key member [member ...]                              | 获取一个或多个位置的geohash值                                | >=3.2.0  | geohash值                   |



## 四、Redis 为什么快

### 4.1 基于内存存储实现

Redis 是基于内存存储实现的数据库，相对于MySQL等数据库，省去了磁盘I/O的消耗



### 4.2 数据结构和编码

MySQL索引为了提高效率，选择了B+数的数据结构。

Redis 底层在实现上述数据结构的时候，会在源码层面针对上述数据结构进行**特定的优化**，来达到节省时间/空间的效果。

同一个数据类型，背后的编码实现方式是不同的，会根据特定场景优化。

编码方式：redis数据结构的底层实现

| 数据结构 | 内部编码                                                     |
| -------- | ------------------------------------------------------------ |
| string   | raw：大于39个字节的字符串<br />embstr：小于等于39字节的字符串<br />int：数字类型 |
| hash     | ziplist：元素个数小于512个，所有值小于64字节<br />hashtable：不满足ziplist情况 |
| list     | ziplist：长度小于512，每个元素小于64字节<br />linkedlist：不满足ziplist情况 |
| set      | intset：集合元素都是整数且小于512个<br />hashtable：不满足intset情况 |
| zset     | ziplist：元素个数小于128个，且每个元素值小于64字节<br />skiplist：不满足ziplist情况 |



跳跃表：是redis特有的数据结构，在链表的基础上，增加多级索引提升查找效率。支持平均O(logN)，最坏O(N) 复杂度的节点查找，还可以通过顺序性操作批量处理节点



### 4.3 线程模型

#### 4.3.1 I/O多路复用

多路I/O复用技术可以让单个线程高效的处理多个连接请求，而 redis 使用 epoll 作为 I/O 多路复用技术的实现。并且，redis 自身的事件处理模型将 epoll 中的连接、读写、关闭都转换为事件，不在网络 I/O 上浪费过多时间

- I/O：网络 I/O 
- 多路：多个网络连接
- 复用：复用同一个线程
- I/O 多路复用其实就是一种同步IO模型，它实现了一个线程可以监视多个文件句柄；一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；而没有文件句柄就绪时，就会阻塞应用程序，交出CPU

#### 4.3.2 单线程模型

Redis 时单线程模型的，而单线程避免了CPU不必要的上下文切换和竞争锁的消耗。也正是因为是单线程，如果某个命令执行过长（如HGETALL），会造成阻塞。Redis 是面向快速执行场景的数据库，要慎用 smembers、lrange、hgetall 等命令。

Redis 6.0 引入了多线程提速，它的执行命令操作内存的仍然是个单线程。



### 4.4  虚拟内粗机制

Redis 自己构建了VM机制，不会像一般的系统会调用系统函数处理，会浪费一定的时间去移动和请求。

虚拟内存机制就是暂时把不经常访问的数据（冷数据）从内存交换到磁盘中，从而腾出宝贵的内存空间用于其他需要访问的数据（热数据）。通过VM功能可以实现冷热数据分离，使热数据仍在内存中，冷数据保存到磁盘。可以避免因为存储不足而造成访问速度下降的问题。



## 五、Redis 常见问题

### 5.1 缓存穿透

**常见的缓存使用方式**：读数据 -> 查询缓存 -> 缓存有值直接返回，没值去查询数据库 -> 把数据库的值更新到缓存中 -> 返回数据

**缓存穿透**：查询一个不存在的数据，缓存无法命中导致每次都去查询数据库，进而给数据库带来压力



产生缓存穿透的情况：

1. 业务设计不合理：大多数用户没有开守护，但是每个请求都去查询userid有没有守护
2. 操作失误：比如缓存和数据库的数据被误删除了
3. 非法请求攻击：比如黑客捏造大量非法请求，读取不存在的业务数据

避免缓存穿透方法：

1. 在API入口对参数进行校验，过滤非法值
2. 查询数据库为空时，给缓存设置个空值（或默认值）。等有写请求进来时更新缓存，以保证数据一致性
3. 使用布隆过滤器快速判断数据是否存在。存在再继续查询



### 5.2 缓存雪奔

**缓存雪奔**：指缓存中数据大批量到过期时间，而查询数据量巨大，请求都直接访问数据库，引起数据库压力过大甚至宕机。

- 缓存雪奔一般是由于大量数据同时过期造成的，对应这个原因，可通过均匀设置过期时间解决（大固定值+小随机值），即让过期时间相对离散一些
- Redis 故障宕机也可能引起缓存雪奔，这时候需要构造 Redis 高可用集群



### 5.3 缓存击穿

**缓存击穿**：指热点 key 在某个时间点过期的时候，而恰好在这个时间点对这个key有大量的并发请求过来，从而大量的请求打到db。

解决方案：

1. 使用互斥锁：缓存失效时，不是立即去加载DB数据，而是先使用某些带成功返回的原子操作命令（如 setnx）去操作，成功的时候再去加载DB数据库数据和设置缓存。否则就去重试获取缓存。
2. 永不过期：是指没有设置过期时间，但是在热点数据快要过期时，异步线程去更新和设置过期时间



### 5.4 热key问题

**热key**：Redis 中访问频率高的key，称为热点key

**热key问题**：某一热key的请求到服务器主机时，由于请求量特别大，可能会导致主机资源不足，甚至宕机，从而影响正常的服务

**热key产生**：

1. 用户消费的数据远大于生产的数据，如秒杀、热点新闻等读多写少的场景
2. 请求分片集中，超过单redis服务器的性能

**识别热key**：

1. 凭经验判断
2. 客户端统计上报
3. 服务代理层上报

**解决方案**：

1. Redis 集群扩容：增加分片副本，均衡读流量
2. 将热key分散到不同的服务器中
3. 使用二级缓存，即JVM本地缓存，减少Redis的读请求



### 5.5 过期策略

**常见过期策略**：

1. **定时过期**：每个设置过期时间的key都创建一个定时器，到过期时间就会立即对key进行清楚。该策略可以立即清除过期数据，对内存很友好，但是会占用大量的CPU资源区处理过期数据，从而影响缓存的响应时间和吞吐量。
2. **惰性过期**：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化节省CPU资源，却对内存非常不友好。可能出现大量过期key没有被再次访问，从而不会被清除。
3. **定期过期**：每个一定时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。expires字典会保存所有设置了过期时间的key的过期时间数据，其中key是指向件空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示过期时间。键空间是指该Redis集群中保存的所有键。

Redis中同时使用了 **惰性过期**和**定期过期** 两种过期策略。



### 5.6 内存淘汰策略

**当内存不足以容纳新写入数据时**，Redis 会进行响应的淘汰策略保护自己。

| 内存淘汰策略    | 当内存不足以容纳新写入数据时                                 |
| --------------- | ------------------------------------------------------------ |
| noeviction      | 新写入操作会报错 （默认策略）                                |
| volatile-lru    | 从设置了过期时间的 key 中，使用 LRU 算法进行淘汰             |
| allkeys-lru     | 从所有key中，使用 LRU 算法进行淘汰                           |
| volatile-lfu    | 从设置了过期时间的key中，使用 LFU 算法进行淘汰 （4.0版本新增） |
| allkeys-lfu     | 从所有key中，使用 LFU 算法进行淘汰（4.0版本新增）            |
| volatile-random | 从设置了过期时间的key中， 随机 淘汰数据                      |
| allkeys-random  | 从所有key中，随机 淘汰数据                                   |
| volatile-ttl    | 从设置了过期时间的key中，根据过期时间淘汰，越早过期的优先被淘汰 |

- LRU：(Least Recently Used) 最近最少使用淘汰算法，淘汰最上时间没有被使用的数据
- LFU：(Least Frequently Used) 最不经常使用淘汰算法，淘汰一段时间内使用次数最少的数据



## 六、常用应用场景

缓存、排行榜、计数器、共享session、分布式锁、社交网络、消息队列、位操作



## 七、持久化

Redis 提供了两种持久化机制 **RDB** 和 **AOF** 。避免服务器挂了导致数据丢失。

### 7.1 RDB

RDB 是把内存数据以快照的形式保存到磁盘上

RDB 持久化，是指在指定的时间间隔内，执行指定次数的写操作，将内存中的数据集快照写入磁盘中，它是 Redis 默认的持久化方式。执行完操作后，在指定目录下生成一个 dump.rdb 文件，Redis 重启的时候，通过加载 dump.rdb 文件来恢复数据。

RDB**触发机制**主要有：

1. 手动触发 save：同步，会阻塞当前 Redis 服务器
2. 手动触发 bgsave：异步，Redis 进程执行fork操作创建子进程
3. 自动触发 save m n：m秒内数据集存在n此修改时，自动触发 bgsave

**优点**：

- 适合大规模的数据恢复场景，如备份，全量复制等

**缺点**：

- 没办法做到实时持久化/秒级持久化
- 老版本存在RDB格式兼容问题



### 7.2 AOF

AOF （append only file）持久化，采用日志的形式来记录每个写操作，追加到文件中，重启时再重新执行AOF文件中的命令来恢复数据。它主要解决数据持久化的实时性问题。默认时不开启的。

**优点**：

- 数据的一致性和完整性更高

**缺点**：

- AOF记录的内容越多，文件越大，数据恢复变慢



## 八、高可用

Redis 实现高可用有三种部署模式：主从模式、哨兵模式、集群模式。

### 8.1 主从模式

主从模式中，Redis 部署了多台机器，有主节点，负责读写操作；有从节点，只负责读操作。从节点的数据来自主节点，实现原理就是**主从复制机制**。

主从复制包括 **全量复制**，**增量复制** 两种。

一般当 slave 第一次启动连接 master，就采用全量复制。全量复制流程如下：

1. slave 发送 sync 命令到master
2. master 接受到 sync 命令后，执行 bgsave 命令，生成RDB全量文件
3. master 使用缓存区，记录RDB快照生成期间的所有写命令
4. master 执行完 bgsave 后，向所有slave 发送 RDB 快照文件
5. slave 收到 RDB 快照文件后，载入、解析收到的快照
6. master 使用缓存区，记录RDB 同步期间生成的所有写命令
7. master 快照发送完毕后，开始向 slave 发送缓冲区中的写命令
8. slave 接受命令请求，并执行来自master缓存区的写命令

Redis 2.8 版本智慧，已经使用 psync 来替代 sync。因为 sync 命令非常消耗系统资源，psync 的效率更高。

slave 与 master 全量同步后，master上的数据如果再次发送更新，就会触发 **增量复制**。

1. master 节点发送数据变化时，触发 replicationFeedSalves() 函数。
2. master 节点上每一个命令会使用 replicationFeedSalves() 来同步到 slave 节点



### 8.2 哨兵模式

主从模式中，一旦主节点由于故障不能提供服务，需要人工将slave节点晋升为master节点，同时还要通知应用方更新主节点地址。显然，多数业务场景不能接受这种故障处理方式。Redis 从2.8 开始正式提供 Redis Sentinel 架构来解决这个问题。

**哨兵模式** 由一个或多个 Sentinel 实例组成的 Sentinel 系统，它可以监视所有的 Redis 主节点和从节点，并在呗监视的主节点进入下线状态时，自动将下线的主服务器属下的某个从节点升级为新的主节点。

一个哨兵进程对 Redis 节点进行监控，就可能出现单点问题，因此，可以使用多个哨兵来进行监控 Redis 节点，并且各个哨兵之间还会进行监控。

**哨兵模式作用**：

1. 发送命令，等待 Redis 服务器 返回监控器运行状态
2. 哨兵检测到主节点宕机，会自动将从节点切换成主节点，然后通过发布订阅模式通知其他的从节点，修改配置文件，让他们切换主机
3. 哨兵之间还会相互监控，从而达到高可用

**哨兵的工作模式**：

1. 每个 Sentinel 以每秒钟一次的频率向它所知的 master、slave 以及其他 Sentinel实例发送一个 PING 命令
2. 如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-millseconds 选项所指定的值，则这个实例会被 Sentinel 标记为主观下线
3. 如果一个 master 被标记为主观下线，则正在监视这个 master 的所有 sentinel 要以每秒一次的频率确认 master 的确进入了主观下线状态
4. 当有足够数量的 sentinel （大于等于配置文件指定的值）在指定时间范围内确认 master 的确进入了主观下线状态，则 master 会被标记为客观下线
5. 在一般情况下，每个 sentinel 会以每10秒一次的频率向它已知的所有 master、slave 发送 info 命令
6. 当 master 被sentinel 标记为客观下线时，sentinel 向下线的 master 的所有 slave 发送 info 命令的频率从10秒改为1秒一次
7. 若没有足够数量的 sentinel 同意 master 已经下线， master 的客观下线状态就会被移除；若master 重新向 sentinel 的 PING 命令返回有效回复， master 的主观下线状态就会被移除



### 8.3 集群模式

哨兵模式基于主从模式，实现读写分离，它还可以自动切换，系统可用性更高。但是它每个节点存储的数据是一样的，浪费内存，并且不好在线扩容。因此，Cluster 集群应运而生，它在 Redis 3.0 加入的，实现了 Redis 的分布式存储。对数据进行分片，也就是说每台 Redis 节点上存储不同的内容，来解决在线扩容的问题。并且它也提供复制和故障转移的功能。

Redis Cluster 集群通过 **Gossip 协议** 进行通信，节点之前不断交换信息，交换的信息内容包括：节点出现故障、新节点加入、主从节点变更信息、slot信息 等等。

常用的 Gossip 消息分为4种：ping、pong、meet、fail。

- **ping** 消息：集群内交换最频繁的消息，集群内每个节点每秒向多个其他节点发送 ping 消息，用于检测节点是否在线和交换批次状态信息
- **pong** 消息：当接收到 ping、meet 消息时，作为响应消息回复给发送方确认消息正常通信。pong 消息内部封装了自身状态数据。节点也可以向集群内广播自身的 pong 消息来通知整个集群对自身状态进行更新
- **meet** 消息：通知新节点加入。消息发送者通知接收者加入到当前集群。
- **fail** 消息：当节点判断集群内另一个节点下线时，会向集群内广播一个 fail 消息，其他节点接收到fail 消息之后把对应节点更新为下线状态

每个节点通过 **集群总线（cluster bus）** 与其他的节点进行通信的。通讯时，使用特殊的端口号，即对外服务端口号加10000。例如某个node端口号时6379，那么它与其他 nodes 通信的端口号时 16379。nodes 之间的通信采用特殊的二进制协议。











## 参考文档

官网：https://redis.io/

源码：https://github.com/redis/redis

命令：http://doc.redisfans.com/

教程：https://www.runoob.com/redis/redis-tutorial.html
