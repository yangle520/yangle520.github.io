---
layout: post
title: 系统架构设计师教程 - 5 - 软件工程
subtitle: 软件工程
date:   2023-01-05 00:00:00
categories: 软考 系统架构设计师教程
tag: 软考
author: YangLe
---







## 一、软件工程

### 1、定义

**软件工程**一直以来都缺乏一个统一的定义，很多学者和组织机构都分别给出了自己的定义：

- Barry Boehm：运用现代科学技术知识来设计并构造计算机程序 及 为开发、运行、维护 这些程序所必须的相关文件资料
- IEEE：软件工程是：①将系统化的、严格约束的、可量化的 方法应用于软件的开发、运行、维护，即将工程化应用于软件；② 对①中所述方法的研究
- Fritz Bauer：建立并使用完善的工程化原则，以较经济的手段获得能在实际机器上有效运行的可靠软件的一系列方法
- 《计算机科学技术百科全书》：软件工程是应用计算机科学、数学、逻辑学、管理科学 等原理，开发软件的工程。软件工程借鉴传统工程的原则和方法，以提高质量、降低成本 和 改进算法。其中
  - 计算机科学、数学用于构建模型与算法；
  - 工程科学用于制定规范、设计范型、评估成本、确定权衡
  - 管理科学用于 计划、资源、质量、成本 等管理

**软件工程过程** 是指为了获得软件产品，在软件工具的支持下由软件工程师完成的一系列软件工程活动，包括以下 4 个方面：

1. P（Plan）：软件规格说明。规定软件的功能及其运行时的限制
2. D（Do）：软件开发。开发出满足规格说明的软件
3. C（Check）：软件确认。确认开发的软件能够满足用户的需求
4. A（Action）：软件演讲。软件在运行过程中不断改进以满足客户新的需求



### 2、软件过程模型

软件要经历从需求分析、软件设计、软件开发、运行维护，直至被淘汰这样的全过程，这个全过程称为**软件的生命周期**。

为了使软件生命周期中的各项任务能够有序地按照规程进行，需要一定地工作模型对各项任务给予规程约束，这样地工作模型被称为软件过程模型，有时也称之为**软件生命周期模型**。



#### 2.1 瀑布模型

**瀑布模型**：

> 需求分析 -> 系统设计 -> 程序设计 -> 编码实现 -> 单元测试 -> 集成测试 -> 系统测试 -> 运行维护

**瀑布模型的特点** 是因果关系紧密相连，前一个阶段工作地输出结果，是后一个阶段工作地输入。每一个阶段都是建筑在前一个阶段正确实施的结果之上。每一个阶段工作完成后都伴随着一个里程碑（一组检查条件），对该阶段的工作进行审查和确认。

**瀑布模型的重要作用**：它的出现有利于人员的组织管理，有利于软件开发方法和工具的研究。

**瀑布模型的缺的**：

1. 软件需求的完整性、正确性等很难确定，甚至是不可能和不现实的。
2. 瀑布模型是一个严格串行化的过程模型，使得用户和软件项目负责人要相当长的时间才能得到一个可以看见的软件系统。如果出现与用户的期望不一致，或者出现需求变更，将会带来巨大的损失。
3. 瀑布模型的基本原则是在每个阶段一次性地完全解决该阶段地工作，不会出现遗漏、错误等情况，而实际上这是不现实或不可能地



#### 2.2 原型化模型

原型模型（Prototype Model）又称快速原型。由于普通模型地缺的，人们借鉴建筑师、工程师建造原型地经验，提出了原型模型。

![图片]({{ '/images/ruankao/framework/5/原型模型.png' | prepend: site.baseurl }})

原型模型主要有以下两个阶段：

1. **原型开发阶段**：软件开发人员根据用户提出地软件系统的定义，快速地开发一个原型。该原型应该包含目标系统地关键问题和反应目标系统地大致面貌，展示目标系统地全部或部分功能、性能等。开发原型可以考虑以下途径：
   - 利用模拟软件系统的人机界面和人机交互方式
   - 真正开发一个原型
   - 找来一个或几个正在运行的类似软件进行比较
2. **目标软件开发阶段**：在征求用户对原型的意见后 对原型进行修改完善，确认软件系统的需求并达到一致的理解，进一步开发实际系统。原型模型的使用应该注意以下内容：
   - 用户对系统的认识模糊不清，无法准确回答目标系统的需求
   - 要有一定的开发环境和工具支持
   - 经过对原型的若干次修改，应收敛到目标范围内，否则可能会失败
   - 对大型软件来说，原型可能会非常复杂而难以快速形成，如果没有现成的原型模型，就不应考虑用原型法



#### 2.3 螺旋模型

螺旋模型（Spiral Model）是在快速原型的基础上扩展而成。

![图片]({{ '/images/ruankao/framework/5/螺旋模型.png' | prepend: site.baseurl }})

螺旋模型把整个软件开发流程分成多个阶段，每一个阶段都由4部分组成：

1. **目标设定**：为该项目进行需求分析，定义和确定这一个阶段的专门目标，指定对过程和产品的约束，并且制定详细的管理计划
2. **风险分析**：对可选方案进行风险识别和详细分析，制定解决办法，采取有效措施避免这些风险
3. **开发和有效性验证**：风险评估后，可以为系统选择开发模型，并且进行原型开发，即开发软件产品
4. **评审**：对项目进行评审，以确定是否需要进入螺旋线的下一次回路，如果决定继续，就要制定下一阶段计划。

螺旋模型的软件开发过程实际是上述4个部分的迭代过程，每迭代依次，螺旋线就增加一圈，软件系统就生成一个新版本，这个新版本实际上是对目标系统的一个逼近。经过若干次的迭代后，系统应该尽快地收敛到用户允许或可以接受的目标范围内，否则也有可能中途夭折。

该模型支持大型软件开发，适用于 面向规格说明、面向过程、面向对象 的软件开发方法，也适用于几种开发方法的组合。



### 3 敏捷模型

软件开发在20世纪90年代受到两个大的因素影响：

- 对内，面向对象编程 开始取代 面向过程编程
- 对外，互联网泡沫导致 快速投向市场 以及 公司的快速发展 成为关键商业因素。



#### 3.1 敏捷方法的特点

敏捷型方法是 **适应性**（adaptive）而非预设性（predicative）。敏捷的目的就是称为适应变化的过程，甚至能允许改变自身来适应变化。

敏捷型方法是 **面向人的**（People-oriented）而非 面向过程的（Process-oriented）。它们试图使软件开发工作能够充分发挥的创造能力。它们强调软件开发应当是一项愉快的活动。

##### 3.1.1 适应性和预设性

软件的设计之所以难以实现，问题在于软件需求的不稳定，从而导致软件过程的不可预测。但是传统的控制项目的模式都是针对可预测的环境，在不可预测的环境下，往往无法使用这些方法。

但是，必须对这样的过程进行监控，以使得整个过程能向期望的目标前进。于是 Agile 方法引入 **适应性** 方法，该方法使用反馈机制对不可预测过程进行控制。

##### 3.1.2 面向人而非面向过程

**传统计划驱动方法**的目标之一是使得一个项目的参与人员成为可替代的部件。这样的一种过程将人看成一种资源，他们具有不同的角色，如分析员、程序员、测试员、管理人员。个体是不重要的，只有角色才是重要的。这样考虑的一个重要的出发点就是：尽量减少人为因素对开发过程的影响。但是，敏捷型方法则正好相反。计划驱动方法 是让软件开发人员 服从 一个过程而非 接受 一个过程。

**敏捷开发过程**还要求开发人员必须有权做技术方面的所有决定。这样一来，就使得开发人员和管理人员在一个软件项目的领导方面有同等的地位，他们共同对整个开发过程负责。

敏捷方法还特别提倡直接的面对面交流。Alistair Cockburn 认为面对面交流的成本要远远低于文档交流的成本。因此，敏捷方法一般都按照高内聚、低耦合的原则将项目划分为若干小组，以增加沟通，提高敏捷性及应变能力。



#### 3.2 敏捷方法的核心思想

敏捷方法的核心思想主要有下面3点：

1. **敏捷方法是适应型，而非可预测型**。与传统方法不同，敏捷方法拥抱变化，可以说它的初衷就是适应变化的需求，利用变化来发展，甚至改变自己，最后完善自己。
2. **敏捷方法是以人为本，而非以过程为本**。传统方法以过程为本，强调充分发挥人的特性，不去限制它。并且软件开发在 无过程控制 和过于严格烦琐的过程控制中取得一种平衡，以保证软件的质量。
3. **迭代增量式的开发过程**。敏捷方法以原型开发思想为基础，采用迭代增量式开发，发行版本小型化。它根据客户需求的优先级和开发风险，制订版本发行计划，每一发行版都是在前一成功发行版的基础上进行功能需求扩充，最后满足客户的所有功能需求。



#### 3.3 主要敏捷方法简介

几种影响比较大的敏捷方法：

3.3.1 极限编程 

3.3.2 水晶系列方法

3.3.3 Scrum

3.3.4 特征驱动开发方法



### 4 统一过程模型 RUP

软件统一过程（Rational Unified Process，RUP）是 Rational 软件公司创造的软件工程方法。RUP 描述了如何有效地利用商业的可靠的方法开发和部署软件，是一种重量级过程。RUP类似一个在线的指导者，它可以为多有方面和层次的程序开发提供指导方针、模板以及事例支持。



#### 4.1 RUP 的生命周期

RUP 软件开发生命周期是一个二维的软件开发模型，有9个核心工作流：

- **业务建模**：Business Modeling，理解待开发系统所在的机构及其商业运作，确保所有参与人员对待开发系统所在的机构有共同的认识，评估待开发系统所在的机构的影响
- **需求**：Requirements，定义系统功能及用户界面，使客户知道系统的功能，使开发人员理解系统的需求，为项目预算及计划提供基础
- **分析与设计**：Analysis & Design，把需求分析的结果转化为分析与设计模型
- **实现**：Implementation，把设计模型转换为实现结果，对开发的代码做单元测试，将不同实现人员开发的模块集成为可执行系统
- **测试**：Test。检查各子系统之间的交互、集成，验证所有需求是否均被正确实现，对发现的软件质量上的缺陷进行归档，对软件质量提出改进建议
- **部署**：Deployment，打包、分发、安然软件，升级旧系统；培训用户及销售人员，并提供技术支持
- **配置与变更管理**：Configuration & Change Management，跟踪并维护系统开发过程中产生的所有制品的完整性和一致性
- **项目管理**：Project Management，为软件开发项目提供计划、人员分配、执行、监控 等方面的指导，为风险管理提供框架
- **环境**：Environment，为软件开发机构提供软件开发环境，即提供过程管理和工具的支持

RUP 把软件开发生命周期划分为多个**循环**（Cycle），每个循环生成产品的一个新的版本，每个循环依次由**4个连续的阶段**（Phase）组成，每个阶段完成确定的任务。这4个阶段如下：

- 初始阶段（inception）：定义最终产品视图和业务模型，并确定系统范围
- 细化阶段（elaboration）：设计及确定系统的体系结构，制订工作计划及资源要求
- 构造阶段（construction）：构造产品并继续演进需求、体系结构、计划直至产品提交
- 移交阶段（transition）：把产品提交给用户使用



#### 4.2 RUP 中的核心概念

RUP 中定义了如下一些核心概念：

- 角色（Role）：Who的问题。角色描述某个人或一个小组的行为与职责。RUP 预先定义了很多角色，如体系结构师（Architect）、设计人员（Designer）、实现人员（Implementer）、测试员（tester）、配置管理人员（Configuration Manager）等，并对每一个角色的工作和职责都做了详尽的说明
- 活动（Activity）：How的问题。活动是一个有明确目的的独立工作单元
- 制品（Artifact）：What的问题。制品是活动生成、创建或修改的一段信息。也有些书把 Artifact 翻译为产品、工件等。
- 工作流（Workflow）：When的问题。工作流描述了一个有意义的连续的活动序列，每个工作流产生一些有价值的产品，并显示了角色之间的关系



#### 4.3 RUP 的特点

RUP 是用例驱动的、以体系结构为中心的、迭代和增量的软件开发过程。

##### 4.3.1 用例驱动

RUP 中的开发活动是用例驱动的，即需求分析、设计、实现和测试等活动都是用例驱动的。

##### 4.3.2 以体系结构为中心

RUP 中的开发活动是围绕体系结构展开的。软件体系结构的设计和代码设计无关，也不依赖于具体的程序设计语言。软件体系结构是软件设计过程中的一个层次，这一层次超越计算过程中的算法设计和数据结构设计。体系结构层次的设计问题包括系统的总体组织和全局控制、通信协议、同步、数据存取、给设计元素分配功能、设计元素的组织、物理分布、系统的伸缩性和性能等。

体系结构的设计需要考虑多方面的问题：

- 在功能性特征方面要考虑系统的功能
- 在非功能性特征方面要考虑系统的性能、安全性、可用性 等
- 与软件开发有关的特征要考虑可修改性、可移植性、可重用性、可集成性、可测试性 等
- 与开发经济学有关的特征要考虑开发实际、费用、系统的生命期 等

当然，这些特征之间有些是相互冲突的，一个系统不可能在所有的特征上都达到最优，这时就需要系统体系结构设计师在各种可能的选择之间进行权衡。

对于一个软件系统，不同人员所关心的内容是不一样的。因此，软件的体系结构是一个多维的结构，也就是说，会采用多个视图来描述软件体系结构。

![图片]({{ '/images/ruankao/framework/5/4+1视图模型.png' | prepend: site.baseurl }})

- **用例视图**：展示 分析人员和测试人员关系的是系统的行为
- **逻辑视图**：展示 最终用户关系的系统功能
- **实现视图**：展示 程序员关心的系统配置、装配等问题
- **进程视图**：展示 系统集成人员关心的系统性能、可伸缩性、吞吐率 等问题
- **部署视图**：展示 系统工程师关心的系统发布、安装、拓扑结构等问题

##### 4.3.3 迭代与增量

RUP 强调采用迭代和增量的方式来开发软件，把整个项目开发分为多个迭代过程。

1. 在每次迭代中，只考虑系统的一部分需求，进行分析、设计、实现、测试、部署等过程
2. 每次迭代是在已完成部分的基础上进行的，每次增加一些新的功能实现
3. 以此进行下去，直至最后项目的完成

采用迭代与增量的方式有以下**优点**：

1. 在软件开发的早期就可以对关键的、影响大的风险进行处理
2. 可以提出一个软件体系结构来指导开发
3. 可以更好的处理不可避免地需求变更
4. 可以较早得到一个可运行地系统，鼓舞开发团队地士气，增强项目成功地信心
5. 为开发人员提供一个能更有效工作地开发过程。



### 5 软件能力成熟度模型

**软件能力成熟度模型** （Capability Maturity Model for Software，**CMM**）是一个概念模型。模型框架和表示是刚性地，不能随意改变，但模型地解释和实现有一定弹性。

**软件能力成熟度模型集成**（Capability Maturity Model Integration for Software，**CMMI**）是在 CMM 的基础上发展而来。主要用于指导软件开发过程的改进和进行软件开发能力的评估。

CMMI 提供了一个软件能力成熟度的框架，它将软件过程改进的步骤组织成5个成熟度等级，共包括：18个关键过程域，52个过程目标，3168种关键时间，它为软件过程不断改进奠定了一个循序渐进的基础。



#### 5.1 初始级

- 该等级下，过程通常是随意且混乱的。
- 这些组织的成功 依赖于组织内人员的能力与英雄主义。
- 这些组织也能产出能用的产品与服务，但它们经常超出在计划中记录的预算与成本

#### 5.2 已管理级

- 该等级下，意味着组织要确保策划、文档化、执行、监督和控制 项目级的过程
- 需要为过程建立明确的目标，并能实现成本、进度、质量目标 等

#### 5.3 已定义级

- 该等级下，企业能够根据自身的特殊情况定义适合自己企业和项目的标准流程
- 将这套管理体系与流程予以制度化，同时企业开始进行项目积累，企业资产的收集

#### 5.4 量化管理级

- 该等级下，组织建立了产品质量、服务质量以及过程性能的定量目标
- 与上一等级的区别 在于对过程性能的可预测

#### 5.5 优化级

- 该等级下，企业的项目管理达到了最高的境界
- 关注于通过增量式的 与 创新式 的过程与技术改进，不断地改进过程性能
- 组织使用从多个项目收集来的数据对整体的组织级绩效进行关注



## 二、需求工程

软件需求目前并没有统一的定义，但都包含以下几方面的内容：

1. 用户解决问题或达到目标所需条件或权能（Capability）。
2. 系统或系统部件要满足 合同、标准、规范 或 其他正式规定文档 所需具有的条件或权能。
3. 一种反映上面 ① 或 ② 所述条件或权能的文档说明。它包括 **功能性需求** 及 **非功能性需求**，非功能性需求对设计和实现提出了限制，比如：性能要求、质量标准、设计限制 等

需求阶段的输出成果为 **用户原始需求说明书** 和 **软件需求描述规约**。需求阶段首先要定义用户的原始需求，并于用户、客户 达成一致；其次，需要对这对原始需求进行分析，给出一个初步的软件解决方案，并给出该软件的需求描述规约，以指导后续的软件开发。

软件需求包括3个不同的层次：**业务需求**、**用户需求**、**功能需求**（也包括非功能需求）

1. **业务需求**：反应了组织机构或客户对系统、产品高层次的目标要求
2. **用户需求**：描述了用户使用产品必须要完成的任务，式用户对该软件产品的期望
3. **功能需求**：定义了开发人员必须实现的软件功能，使得用户能完成它们的任务，从而满足业务需求。

所谓 **特性**（feature）是指逻辑上相关的功能需求的集合，给用户提供处理能力并满足业务需求。作为补充，软件需求规格说明还应包括非功能需求，它描述了系统展现给用户的行为和执行的操作等。它包括：

- 产品必须遵从的标准、规范、合约
- 外部界面的具体细讲
- 性能要求
- 设计或实现的约束条件：是指对开发人员在软件产品设计和构造上的限制，常见的有设计约束和过程约束
- 质量属性：是通过多种角度对产品的特点进行描述，从而反应产品功能

**需求工程** 是指应用已证实有效的原理、方法，通过合适的工具和记号，系统地描述待开发系统及其行为特征和相关约束。 **需求工程**覆盖了体系结构设计之前的各项**开发活动**，主要包括分析客户要求、对未来系统的各项功能性及非功能性需求进行规格说明。

**需求工程的活动阶段**：

1. **需求获取**：通过与用户的交流，对现有系统的观察及对任务进行分析，从而开发、捕获、修订用户的需求
2. **需求分析**：为系统建立一个概念模型，作为对需求的抽象描述，并尽可能多的捕获现实世界的语义。
3. **形成需求规格**（需求文档化）：按照相关标准，生成需求模型的文档描述，用户原始需求书作为用户和开发者之间的一个协约，往往被作为合同的附件；软件需求描述规约作为后续软件系统开发的指南
4. **需求确认与验证**：以需求规格说明为输入，通过用户确认、复审会议、符号执行、模拟仿真、快速原型 等途径与方法，确认和验证需求规格的完整性、正确性、一致性、可测试性、可行性，包含有效性检查、一致性检查、可行性检查、确认可验性
5. **需求管理**：包括需求文档的追踪管理、变更控制、版本控制等管理性活动

软件需求开发的最终文档经过评审批准后，则定义了开发工作的**需求基线**。这个基线在客户和开发者之间构筑了计划产品功能需求和非功能需求的一个约定。**需求约定**是 需求开发 和 需求管理 之间的桥梁。

**需求管理** 是对一个系统需求**变更**、**了解**和**控制**的过程。需求管理过程与需求开发过程相互关联，当初始需求导出的同时就启动了需求管理规划，一旦形成了需求文档的初稿，需求管理活动就开始了。**需求管理的主要活动**：

1. 变更控制：建议变更、分析影响、做出决策、交流、合并、测量需求的稳定性
2. 版本控制：确定需求文档版本、确定单个需求文档版本
3. 需求跟踪：定义对其他需求的连接链、定义对其他系统元素的连接链
4. 需求状态跟踪：定义需求状态、跟踪需求每一个状态

**需求管理强调的内容**如下：

1. 控制对需求基线的变动
2. 保持项目计划与需求一致
3. 控制单个需求和需求文档的版本情况
4. 管理需求和联系链，或管理单个需求和其他项目可交付产品之间的依赖关系
5. 跟踪基线中的需求状态



### 1 需求获取

**需求陈述的内容**包括：**问题范围**、**功能需求**、**应用环境**、**假设条件** 等。此外，也包含涉及相关**软件工程标准**、**技术方案**、将来可能做的**扩充及可维护性要求**等方面的约束条件。需求陈述应该阐明 做什么 而不是 怎么做。

**需求获取**是开发者、用户之间为了定义新系统而进行的交流，需求获取是获得系统必要的特征，或者是获得用户能接受的、系统必须满足的约束。



#### 1.1 需求获取的基本步骤

对于不同规模及不同类型的项目，需求获取的过程不会完全一样，下面给出需求获取过程的参考步骤：

1. **开发高层的业务模型**：建立一个业务模型，描述用户的业务过程，确定用户的初始需求。然后通过迭代，更深入地了解应用领域，之后再对业务模型进行改进。
2. **定义项目范围和高层需求**：即在项目开始之前，在所有涉众之间建立共同的项目愿景。项目范围 描述系统的边界以及系统与系统交互的参与者之间的关系（包括组织、人、硬件设备、其他软件等）。高层需求不涉及过多的细节，主要表示系统需求的概貌。常见的建模手段包括**系统上下文图**、**系统顶层用例图** 等。
3. **识别用户角色和用户代表**：涉众不仅包括传统的用户、客户等，还包括测试人员、维护人员、市场人员等，他们也对项目有利益诉求。因此，首先确定所有涉众，然后挑选出每一类涉众并与他们一起工作。用户角色可以是人，也可以是与系统打交道的其他应用程序或硬件部件。如果是其他应用程序或硬件部件，则需要以熟悉这些系统或硬件的人员作为用户代表。
4. **获取具体的需求**：确定了项目范围和高层需求，并确定了所有涉众后，就需要获取每个涉众的具体、完整、详细的需求
5. **确定目标系统的业务工作流**：具体到当前待开发的应用系统，确定系统的业务工作流和主要的业务规则。往往需要采取多重方法来获取所需的信息。
6. **需求整理与总结**：最后对上面步骤取得的需求资料进行整理和总结，确定对软件系统的综合要求，即软件的需求。并提出这些需求的实现条件，以及需求应达到的标准。这些需求包括功能需求、性能需求、环境需求、可靠性需求、安全保密需求、用户界面需求、资源使用需求、软件成本消耗与开发进度需求等。



#### 1.2 需求获取方法

针对不同类型的软件项目，需要采用不同的**需求获取方法**，常见的有：

1. **用户面谈**：这是一种最常见的需求获取方法，是理解用户需求的最有效方法。
   - 面谈过程需要认真的计划和准备；
   - 面谈之后，需要复查笔记的准确性、完整性、可理解性
   - 把所收集的信息转化为适当的模型和文档
   - 确定需要进一步澄清的问题
2. **需求专题讨论会**：在短暂而紧凑的时间段内将相关涉众集中在一起集体讨论，与会者可以在应用需求上达成共识，对操作过程尽快取得统一的意见。参加会议的人员包括主持人、用户、技术人员、项目组人员。专题讨论会具有以下优点：
   - 协助建立一支高效的团队，围绕项目成功的目标
   - 所有的风险承担人都畅所欲言
   - 促进风险承担人和开发团队之间达成共识
   - 揭露和解决那些妨碍项目成功的行政问题
   - 能够很快地产生初步地系统定义
   - 可以有效地解决不同涉众之间地需求冲突
3. **问卷调查**：问卷调查可用于确认假设和收集统计倾向数据。存在地问题是：相关问题不能事先决定，问题背后地假设对答案造成偏颇，难以探索一些新领域，难以继续用户地模糊响应。在完成最初地面谈和分析后，问卷调查可作为一项协作技术收到良好效果
4. **现场观察**：该方法主要是通过观察用户实际执行业务的过程，来直观地了解业务地执行过程，全面了解需求细节。执行业务可能是手工操作，也可能是在原有地业务系统上执行
5. **原型化方法**：在需求的早期，用户往往在具体的需求定义上存在很多不确定性，尤其是信息系统的人机交互界面和查询报表类的需求上。此时往往可以通过在需求阶段采用原型化方法，通过开发系统原型以及与用户的多次迭代反馈，解决在早期阶段需求不确定的问题，尤其是在人机界面等高度不确定的需求
6. **头脑风暴法**：在一些新业务拓展的软件项目中，由于业务是新出现的，而且业务流程存在高度的不确定性，例如互联网上的新业务系统、APP等，一群人围绕该业务，发散思维，不断产生新的观点，参会者敞开思想使各种设想在相互碰撞中激起大脑的创造性风暴，从而确定具体的需求



### 2 需求变更

需求变更的原因有很多种：

- 可能是需求获取不完整，存在遗漏
- 可能是对需求的理解产生了误差
- 可能是业务变化导致了需求的变化

软件需求文档应该精确描述要交付的产品，这是一个基本的原则。为了使开发组织能够严格控制软件项目，应该确保：

- 仔细评估已建议的变更
- 挑选合适的人选对变更做出判定
- 变更应及时通知所有相关人员
- 项目要按一定的程序来采纳需求变更，对变更的过程和状态进行控制



#### 2.1 变更控制过程

变更控制过程用来**跟踪已建议变更的状态**，一旦确定了需求基线，应该使所有已建议的变更都遵循变更控制过程。

![图片]({{ '/images/ruankao/framework/5/需求变更管理过程.png' | prepend: site.baseurl }})

1. **问题分析和变更描述**：当提出一份变更提议后，需要对该提议做进一步的问题分析，检查它的有效性，从而产生一个更明确的需求变更提议。
2. **变更分析和成本计算**：当接受该变更提议后，需要对需求变更提议进行影响分析和评估。变更成本计算应该包括对该变更所引起的所有改动的成本。例如修改需求文档、相应的设计、实现等工作成本。
3. **变更实现**：当确定执行该变更后，需要根据该变更的影响范围，按照开发的过程模型执行相应的变更。
   - 在计划驱动过程模型中，往往需要回溯到需求分析阶段开始，重新作对应的需求分析、设计、实现等步骤；
   - 在敏捷开发模型中，往往会将需求变更纳入到下一次迭代的执行过程中

变更控制过程并不是给变更设置障碍。相反，她是一个渠道和过滤器，通过它可以确保采纳最合适的变更，使变更产生的负面影响降到最低。

**常见的需求变更策略**：

1. 所有需求变更必须遵循变更控制过程
2. 对于未获得批准的变更，不应该做设计和实现工作
3. 变更应该由项目变更控制委员会决定实现哪些变更
4. 项目风险承担者应该能够了解变更的内容
5. 绝不能从项目配置库中删除或者修改变更请求的原始文档
6. 每一个集成的需求变更必须能跟踪到一个经核准的变更请求，以保持水平可追踪性



#### 2.2 变更控制委员会

变更控制委员会（Change Control Board，CCB）是项目所有者权益代表，负责裁定接受哪些变更。CCB 由项目所涉及的多方成员共同组成，通常包括用户和实施方的决策人员。CCB 是决策机构，不是作业机构，通常 CCB 的工作是通过评审手段来决定项目是否能变更，但不提出变更方案。

变更控制委员会应该有一个总则，用于描述变更控制委员会的目的、授权范围、成员构成、做出决策的过程及操作步骤。总则也应该说明举行会议的频度和事由。管理范围描述该委员会能做什么样的决策，以及有哪一类决策应上报到高一级的委员会。过程及操作步骤如下：

1. 制定决策
2. 交流情况
3. 重新协商约定



### 3 需求追踪

需求跟踪包括编制每个需求同系统元素之间的联系文档，这些元素包括其他需求、体系结构、其他设计部件、源代码模块、测试、帮助文件、文档等，是要在整个项目的工件之间形成水平可追踪性。跟踪能力信息使变更影响分析十分便利，有利于确认和评估实现某个建议的需求变更所必须的工作。





