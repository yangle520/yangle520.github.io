---
layout: post
title: 系统架构设计师教程 - 7 - 系统架构设计基础知识
subtitle: 系统架构设计基础知识
date:   2023-01-07 00:00:00
categories: 软考 系统架构设计师教程
tag: 软考
author: YangLe
---





软件架构 （Software Architecture，SA）



## 一、软件架构概念

### 1 软件架构的定义

> 一个程序和计算机系统架构是指系统的一个或者多个结构。结构中包括软件的构件，构件的外部可见属性以及它们之间的相互关系。

架构并非可运行软件。确切地说，它是一种表达，使软件工程师能够：

1. 分析设计在满足所有规定地需求方面地有效性
2. 在设计变更相对容易地阶段，考虑体系结构可能地选择方案
3. 降低与软件构造相关联地风险

在架构设计地环境中，软件构件简单到可以是 程序模块 或者 面向对象地类，也可以扩充到包括 数据库 和 能够完成客户与服务器网络配置的中间件。

软件架构的设计通常考虑到两个层次：

- **数据设计**：体现传统系统中体系结构的数据构件和面向对象系统中类的定义（封装了属性和操作）
- **架构设计**：主要关注软件构件的结构、属性、交互作用

建立架构层 "内聚的、良好设计的表示" 所需的方法，其目标是提供一种导出架构设计的系统化方法，而架构设计是构建软件的初始蓝图。



### 2 软件架构设计与生命周期

#### 2.1 需求分析阶段

需求分析 和 SA 设计面对的是不同的对象。一个是**问题空间**；一个是**解空间**。

保持二者的可追踪性和可转换性，一直是软件工程领域追求的目标。从 需求模型 向 SA模型 转换主要关注两个问题：

1. 如何根据需求模型构建 SA 模型
2. 如何保证模型转换的可追踪性

在采用 Use Case 图描述需求的方法中，从 Use Case 图向 SA 模型的转换一般经过词法分析和一些经验规则完成，而可追踪性则可通过表格或者 Use Case Map 等来维护。



#### 2.2 设计阶段

这一阶段的 SA 研究主要包括：SA 模型的描述、SA模型的设计与分析方法、SA设计经验的总结与复用等。有关 SA 模型的描述的研究分为3个层次：

1. **SA 的基本概念**：即 SA 模型的组成元素，及这些组成元素之间按照何种原则组织。传统的设计概念只包括构件（模块）以及一些基本的模块互联机制。后来构件间的互联机制逐渐独立出来，成为与构件同等级别的实体，称为连接子。现阶段的 SA 描述方法是构件和连接子的建模。
2. **体系结构描述语言**：（Architecture Description Language，ADL）支持构件、连接子 及其配置的描述语言。ADL 对连接子的重视成为区分 ADL 和 其他建模语言的重要特征之一。典型的 ADL 包括：Union、Rapide、Darwin、Wright、C2 SADL、Acme、xADL、XYZ/ADL、ABC/ADL 等。
3. **SA 模型的多视图表示**：从不同的视角描述特定系统的体系结构，从而得到多个视图，并将这些视图组织起来以描述整体的 SA 模型。系统的每一个不同侧面的视图反映了一组系统相关人员所关注的系统的某一特定方面，多视图体现了关注点分离的思想。

典型多视图方案的包括：

- **4+1模型**：逻辑视图、进程视图、开发视图、物理视图、加上统一的场景
- **Hofmesiter的4视图模型**：概念视图、模块视图、执行视图、代码视图
- **View and Beyond模型**：模块视图、构件和连接子视图、分配视图

多视图描述 SA 模型的标准：

- IEEE标准1471-2000 软件密集型系统系统结构描述推荐实践
- 开放分布式处理参考模型（RM-ODP）
- 统一建模语言（UML）
- Zachman框架



#### 2.3 实现阶段

最初的 SA 研究往往只关注较高层次的系统设计、描述和验证。为了有效实现从 SA 设计向实现的转换，实现阶段的体系结构研究表现在以下几个方面：

1. 研究基于 SA 的开发过程支持，如项目组织结构、配置管理等
2. 寻求从 SA 向实现过渡的途径，如将程序设计语言元素引入 SA 阶段、模型映射、构件组装、复用中间件平台等。
3. 研究基于 SA 的测试技术

对于大型软件系统而言，由于参与实现的人员较多，所以需要提供适当的配置管理手段。SA 引入能够有效扩充现有配置管理的能力，通过在 SA 描述中引入版本、可选择项等信息，可以分析和记录不同版本构件和连接子之间的演化，从而可用来组织配置管理的相关活动。

为了填补高层 SA 模型和底层实现之间的鸿沟，可通过封装底层的实现细节、模型转换、精化等手段缩小概念之间的差距。典型方法如下：

1. 在 SA 模型中引入实现阶段的概念，如引入程序设计语言元素等
2. 通过模型转换技术，将高层的 SA 模型逐步精化成能够支持实现的模型
3. 封装底层的实现细节，使之成为较大粒度构件，在 SA 指导下通过构件组装的方式实现系统



#### 2.4 构件组装阶段

在构件组装的过程中，SA 设计模型起到了系统蓝图的作用。研究内容包括如下两个方面：

1. 如何支持可复用构件的互联，即对 SA 设计模型中规约的连接子的实现提供支持
2. 在组装过程中，如何检测并消除体系结构失配问题

中间件遵循特定的构件标准，为构件互联提供支持，并提供相应的公共服务，如安全服务、命名服务等。中间件支持的连接子实现由如下优势：

1. 中间件提供了构件之间跨平台交互的能力，且遵循特定的工业标准，如 CORBA、J2EE、COM 等，可以有效地保证构件之间地通信完整性
2. 产品化地中间件可以提供强大地公共服务能力，这样能够更好地保证最终系统地质量属性。

失配是指在软件复用地过程中，由于待复用构件对最终系统地体系结构和环境地假设与实际状况不同而导致地冲突。在构件组装阶段地失陪问题主要包括3个方面：

1. 由构件引起地失配：包括由于系统对构件基础设施、构件控制模型和构件数据模型地假设存在冲突引起地失配
2. 由连接子引起地失配：包括由于系统对构件交互协议、连接子数据模型地假设存在冲突引起地失配
3. 由于系统成分对全局体系结构地假设存在冲突引起地失配等。要解决失配问题，首先需要能够检测出失配问题，并在此基础上通过适当地手段消除检测地失配问题。



#### 2.5 部署阶段

SA 对软件部署作用如下：

1. 提供高层地体系结构视图来描述部署阶段地软硬件模型
2. 基于 SA 模型可以分析部署方案地质量属性，从而选择合理地部署方案



#### 2.6 后开发阶段

后开发阶段是指软件安装之后地阶段。这一阶段的 SA 研究主要围绕维护、演化、复用等方面来进行。典型的研究方向包括 **动态软件体系结构**、**体系结构恢复与重建** 等。

1. **动态软件架构**
   - **架构设计阶段的支持**：主要包括变化的描述、如何根据变化生成修改策略、描述修改过程、在高抽象层次保证修改的可行性以及分析、推理修改所带来的影响
   - **运行时刻基础设施的支持**：主要包括系统架构的维护、保证架构修改在约束范围内、提供系统的运行时刻信息、分析修改后的体系结构符合指定的属性、正确映射体系结构构造元素的变化到实现模块、保证系统的重要子系统的连续执行并保持状态、分析和测试运行系统 等。
2. **体系结构恢复与重建**：是指从已实现的系统中获取架构的过程。一般地，SA 重建地输出是一组系统结构视图。现有地体系结构重建方法可以分为4类：
   - 手工体系结构重建
   - 工具支持地手工重建
   - 通过查询语言来自动建立聚集
   - 使用其他技术，比如数据挖掘等

### 3 软件架构的重要性

软件架构设计事降低成本、改进质量、按时、按需交付产品的关键因素

1. 架构设计能够满足系统的品质
2. 架构设计使受益人达成一致目标
3. 架构设计能够支持计划编制过程
4. 架构设计对系统开发的指导性
5. 架构设计能够有效地管理复杂性
6. 架构设计为复用奠定了基础
7. 架构设计能够降低维护费用
8. 架构设计能够支持冲突分析



## 二、基于架构的软件开发方法

### 1 架构设计方法概述

基于架构的软件设计（Architecture-Based Software Design，ABSD）方法。

ABSD 方法是由架构驱动的，即指由构成体系结构的**商业**、**质量**和**功能需求**的组合驱动。

ABSD方法有3个基础：

1. **功能的分解**：在功能分解中，ABSD 方法使用已有的基于模块的内聚和耦合技术
2. **通过选择架构风格来实现质量和商业需求**
3. **软件模板的使用**，软件模板利用了一些软件系统的结构

ABSD 方法是递归的，且迭代的每一个步骤都是清晰定义的。因此，不管设计是否完成，体系结构总是清晰的，这有助于体系结构设计的随意性。



### 2 概念与术语

#### 2.1 设计元素

ABSD 方法是一个自顶向下，递归细化的方法，软件系统的体系结构通过该方法得到细化，直到能产生软件构件和类。

![图片]({{ '/images/ruankao/framework/5/ABSD方法过程.png' | prepend: site.baseurl }})

#### 2.2 视角与视图

考虑架构时，要从不同的视角（Perspective）来观察对架构的描述，需要软件设计师考虑架构的不同属性：

- 展示功能组织的静态视角能判断质量特性
- 展示并发行为的动态视角能判断系统行为特性

选择的特定视角或视图（逻辑视图、进程视图、实现视图、配置视图）可以全方位的考虑架构设计。使用逻辑视图来记录元素的功能和概念接口，设计元素的功能定义了它本身在系统中的角色，这些角色包括功能、性能等。

#### 2.3 用例和质量场景

用例是系统的一个给予用户一个结果值的功能点，用例用来捕获功能需求。

在使用用例捕获功能需求的同时，人们通过定义特定场景来捕获质量需求，并称这些场景为**质量场景**。

人们使用质量场景捕获变更、性能、可靠性和交互性，分别称之为变更场景、性能场景、可靠性场景、交互性场景。

质量场景必须包括预期的和非预期的场景。非预期场景可能不会真正实现，但它们在决定设计的边界条件时很有用。



### 3 基于架构的开发模型

传统的软件开发过程可以划分为从概念直到实现的若干个阶段。包括：问题定义、需求分析、软件设计、软件实现、软件测试等。

ABSD 模型把整个基于体系结构的软件过程划分为：**架构需求** -> **设计** -> **文档化** -> **复审** -> **实现** -> **演化**。



### 4 架构需求

**需求** 是指用户对目标软件系统在功能、行为、性能、设计约束等方面的期望。

**需求过程** 是获取用户需求，标识系统中所要用到的构件。

![图片]({{ '/images/ruankao/framework/5/架构需求过程.png' | prepend: site.baseurl }})

#### 4.1 需求获取

架构需求一般来自3个方面，分别是系统的质量目标、系统的商业目标、系统开发人员的商业目标。

软件架构需求获取过程 主要是定义开发人员必须实现的软件功能，使得用户能完成他们得任务，从而满足业务上得功能需求。与此同时，还有获得软件质量属性，满足一些非功能需求。

#### 4.2 标识构件

标识构件过程可以分为3步实现：生成类图 -> 对类进行分组 -> 把类打包成构件

1. **生成类图**：生成类图得CASE 工具很多，例如 Rational Rose 2000
2. **对类进行分组**：在生成得类图基础上，使用一些标准对类进行分组可以大大简化类图结构，使之更清晰。
   - 与其他类隔离得类形成一个组
   - 由概括关联的类组成一个附加组
   - 由聚合或合成关联的类形成一个附加组
3. **把类打包成构件**：把在第2步得到的类簇打包成构件，这些构件可以分组合并成更大的构件



### 5 架构设计

架构需求用来激发和调整设计决策，不同的视图被用来表达与质量目标有关的信息。

架构设计是一个迭代过程：提出架构模型 -> 映射构件 -> 分析构件相互作用 -> 产生架构 -> 设计评审

1. **提出软件体系结构模型**：选择一个合适的架构风格。在这个风格的基础上，开发人员通过体系结构模型，可以获得关于体系结构属性的理解，该模型为将来的实现和演化过程建立了目标
2. **把已标识的构件映射到软件架构中**：把架构需求阶段已标识的构件映射到体系结构中，将产生一个中间结构，这个中间结构只包含那些能明确适合体系结构模型的构件
3. **分析构件之间的相互作用**：为了把所有已标识的构件集成到架构中，必须认证分析这些构件的相互作用和关系
4. **产生软件架构**：一旦决定了关键构件之间的关系和相互作用，就可以在第2阶段得到的中间结构的基础上进行精化
5. **设计评审**：一旦设计了软件架构，必须邀请独立于系统开发的外部人员对体系结构进行评审



### 6 架构文档化

绝大多数的架构都是抽象的，由一些概念上的构件组成。例如：层的概念在任何程序设计语言中都不存在。因此，要让系统分析员和程序员去实现架构，还必须将架构进行文档化。

文档是在系统演化的每一个阶段，系统设计与开发人员的通信媒介，是为验证架构设计和提炼或修改这些设计所执行预先分析的基础。

架构文档化过程的主要输出结构是两个文档：**架构规格说明** 和测试架构需求的 **质量设计说明书**。

文档的完整性和质量是软件架构成功的关键因素。文档要从使用者的角度进行编写，必须分发给所有与系统有关的开发人员，且必须保证开发者手上的文档是最新的。



### 7 架构复审

鉴于架构文档标准化以及风险识别的现实情况，通常人们根据架构设计，搭建一个可以运行的最小化系统用于评估和测试架构是否满足需要。是否存在可识别的技术和协作风险。

复审的目的是标识潜在的风险，及早发现架构设计中的缺陷和错误，包括：

- 架构能否满足需求
- 质量需求是否在设计中得到体现
- 层次是否清晰
- 构件的划分是否合理
- 文档表达是否明确
- 构件的设计是否满足功能与性能的要求



### 8 架构实现

实现：就是要用实体来显示出一个软件架构，即要符合架构所描述的结构设计决策，分割成规定的构件，按规定方式互相交互。下图中虚线框部分是架构实现过程。

![图片]({{ '/images/ruankao/framework/7/架构实现过程.png' | prepend: site.baseurl }})

整个实现过程是以复审后的文档化的架构说明书为基础的，每个构件必须满足软件架构中说明的对其他构件的责任。这些决定即实现的约束是在系统级或项目范围内给出的，每个构件上工作的实现者是看不见的。

在架构说明书中，已经定义系统中的构件与构件之间的关系。因为在架构层次上，构件接口约束 对外唯一的代表了构件，所以可以从构件库中查找符合接口约束的构件，必要时开发新的满足要求的构件。然后，按照设计提供的结构，通过组装支持工具把这些构件的实现体组装起来，完成整个软件系统的连接与合成。

最后一步是测试，包括：单个构件的功能性测试、被组装的应用的整体功能、性能测试。



### 9 架构演化

![图片]({{ '/images/ruankao/framework/7/架构演化过程.png' | prepend: site.baseurl }})

1. **需求变化归类**：首先必须对用户需求的变化进行归类，使变化的需求与已有构件对应。对找不到对应构件的变动，也要做好标记，在后续工作中，将创建新的构件应对这部分变化
2. **制订架构演化计划**：在改变原有结构之前，开发组织必须制订一个周密的架构演进计划，作为后续演化开发工作的指南
3. **修改、增加、删除构件**：在演化计划的基础上，开发人员可根据在第1步得到的需求变动的归类情况，决定是否修改/删除/新增构件。最后对变化的构件进行功能性测试
4. **更新构件的相互作用**：随着构件的新增、删除、修改，构件之间的控制流必须得到更新
5. **构件组装与测试**：通过组装支持工具把这些构件的实现体组装起来，完成整个软件系统的连接与合成，形成新的架构。然后对组装后的系统整体功能和性能进行测试
6. **技术评审**：对以上步骤进行确认，进行技术评审。评审组装后的架构是否反映需求变动、符合用户需求。如果不符合 则需要在第2步到第6步之间进行迭代、



## 三、软件架构风格

软件架构设计的一个核心目标是重复的架构模式，即达到架构级的软件复用。也就是说，在不同的软件系统中，使用同一架构。

基于这个目标，主要任务是研究和实践软件架构风格和类型问题。



### 1 软件架构风格概述

软件架构风格是描述某一特定应用领域中系统组织方式的惯用模式。

架构风格定义一个系统家族，即一个架构定义一个词汇表和一组约束。

- **词汇表**中包含一些构件和连接件类型
- **约束**指出系统是如何将这些构件和连接件组合起来的

架构风格反映了领域中众多系统所共有的结构和语义特性，并指导如何将各个模块和子系统有效地组织成一个完整的系统。



### 2 数据流 架构风格

#### 2.1 批处理架构风格

![图片]({{ '/images/ruankao/framework/7/批处理架构风格示意图.png' | prepend: site.baseurl }})

每个处理步骤是一个单独的程序，每一步必须在前一步结束后才能开始，并且数据必须是完整的，以整体的方式传递。

它的基本构件是独立的应用程序，连接件是某种类型的媒介。连接件定义了相应的数据流图，表达拓扑结构。

#### 2.2 管道/过滤器架构风格

![图片]({{ '/images/ruankao/framework/7/管道过滤器架构风格.png' | prepend: site.baseurl }})

当数据源源不断地产生，系统就需要对这些数据进行若干处理（分析、计算、转换等）。现有地解决方案是把系统分解为几个序贯地处理步骤，

- 这些步骤之间通过数据流连接、一个步骤地输出是另一个步骤地输入。
- 每个处理步骤由一个过滤器（Filter）实现
- 过滤器从管道中读取输入地数据流，经过内部处理，然后产生输出数据流 并写入管道中



### 3 调用/返回 架构风格

调用/返回风格 是指在系统中采用了调用与返回机制。

利用 调用/返回 实际上是一种分而治之地策略，其主要思想是将一个复杂地大系统分解为若干子系统，以便降低复杂度，并且增加可修改性。

调用/返回 架构风格主要包括：主程序/子程序风格、面向对象风格、层次型风格、客户端/服务器风格。



#### 3.1 主程序/子程序 风格

主程序/子程序风格一般采用单线程控制，把问题划分为若干处理步骤，构件即为主程序和子程序。

- 子程序通常可合成为模块
- 过程调用作为交互机制，即充当连接件
- 调用关系具有层次性，其语义逻辑表现为子程序地正确性取决于她调用地子程序地正确性



#### 3.2 面向对象 架构风格

抽象数据类型概念对软件系统有着重要作用，目前软件界已普遍转向使用面向对象系统。

这种风格建立在**数据抽象**和**面向对象**地基础上，数据的表示方法和他们地相应操作封装在一个抽象数据类型或对象中。这种风格的构件是对象，或者说是抽象数据类型的实例。

![图片]({{ '/images/ruankao/framework/7/面向对象架构风格.png' | prepend: site.baseurl }})



#### 3.3 层次型 架构风格

![图片]({{ '/images/ruankao/framework/7/层次型架构风格.png' | prepend: site.baseurl }})

层次系统组成一个层次结构，每一层为上层提供服务，并作为下层的客户。

连接件由通过决定层间如何交互的协议来定义，拓扑约束包括对相邻层提供相同的接口，允许每层用不同的方法实现，这同样为软件重用提供了强大的支持。



#### 3.4 客户端/服务器 架构风格

C/S 软件架构是基于资源不对等，且为实现共享而提出的。

两层 C/S 架构有3个主要组成部分：数据库服务器、客户应用程序、网络。服务器(后台)负责数据管理，客户机（前台）完成与用户的交互任务，称为"胖客户机，瘦服务器"。

![图片]({{ '/images/ruankao/framework/7/两层CS架构风格.png' | prepend: site.baseurl }})

三层 C/S 结构增加了一个应用服务器。整个应用逻辑驻留在应用服务器上，只有表示层存在于客户机上，故称为"瘦客户机"。应用功能分为表示层、功能层、数据层。

- 表示层 是应用的用户接口部分，通常使用图形用户界面
- 功能层 是应用的主体，实现具体的业务处理逻辑
- 数据层 是数据库管理系统

![图片]({{ '/images/ruankao/framework/7/三层CS架构风格.png' | prepend: site.baseurl }})



### 4 以数据为中心的架构风格

以数据为中心的架构风格主要包括：仓库架构风格、黑板架构风格

#### 4.1 仓库架构风格

![图片]({{ '/images/ruankao/framework/7/仓库架构风格.png' | prepend: site.baseurl }})

仓库（Repository）是存储和维护数据的中心场所。在仓库风格中，有两种不同的构件：中央数据结构说明当前数据的状态以及一组对中央数据进行操作的独立构件，仓库与独立构件间的相互作用在系统中会有大的变化。这种风格的连接件即为仓库与独立构件之间的交互。

#### 4.2 黑板架构风格

黑板架构风格适用于解决复杂的非结构化的问题，能在求解过程中综合运用多种不同知识源，使得问题的表达、组织和求解变得比较容易。

黑板系统是一种问题求解模型，是组织推理步骤、控制状态数据和问题求解之领域知识的概念框架。它将问题的解空间组织成一个或多个应用相关的分级结构。分级结构的每一层信息由一个唯一的词汇来描述，它代表了问题的部分解。领域相关的知识被分成独立的知识模块，它将某一层次中的信息转换成同层或相邻的信息。各种应用通过不同知识表达方法、推理框架和控制机制的组合来实现。影响黑板系统设计的最大因素是应用问题本身的特性，但是支撑应用程序的黑板架构有许多相似的特征和构件。

对于特定的应用问题，黑板系统可通过选取各种黑板、知识源和控制模块的构件来设计，也可以利用预先定制的黑板架构的编程环境。黑板系统的传统应用是信号处理领域，如语音识别和模式识别。另一应用是松耦合代理数据共享存取。

![图片]({{ '/images/ruankao/framework/7/黑板架构风格.png' | prepend: site.baseurl }})



### 5 虚拟机架构风格

虚拟机架构风格的基本思想是人为构建一个运行环境，在这个环境之上，可以解析与运行自定义的一些语言，这样来增加架构的灵活性。虚拟机架构风格主要包括：解释器风格、规则系统风格。

#### 5.1 解释器架构风格

![图片]({{ '/images/ruankao/framework/7/解释器架构风格.png' | prepend: site.baseurl }})

一个解释器通常包括：

- 完成解释工作的解释引擎
- 包含将被解释的代码的存储区
- 记录解释引擎当前工作状态的数据结构
- 记录源代码被解释执行进度的数据结构

具有解释器风格的软件中含有一个虚拟机，可以仿真硬件的执行过程和一些关键应用。解释器通常被用来建立一种虚拟机以弥合程序语义与硬件语义之间的差异。其缺点是执行效率较低。典型的例子是专家系统。

#### 5.2 规则系统架构风格

![图片]({{ '/images/ruankao/framework/7/规则系统架构风格.png' | prepend: site.baseurl }})

基于规则的系统包括：规则集、规则解释器、规则/数据选择器、工作内存



### 6 独立构件架构风格

独立构件风格主要强调系统中的每个构件都是相对独立的个体，它们之间不直接通信，以降低耦合度，提升灵活性。独立构件风格主要包括：进程通信、事件系统风格。

#### 6.1 进程通信架构风格

在进程通信结构架构风格中，构件是独立的过程，连接件是消息传递。这种风格的特点是构件通常是命名过程，消息传递的方式可以是点到点、异步或同步方式及远程过程调用等。

#### 6.2 事件系统架构风格

![图片]({{ '/images/ruankao/framework/7/事件系统架构风格.png' | prepend: site.baseurl }})

事件系统风格基于事件的隐式调用风格的思想，是构件不直接调用一个过程，而是触发或广播一个或多个事件。

系统中的其他构件中的过程在一个或多个事件中注册，当一个事件被触发，系统自动调用在这个事件中注册的所有过程，这样，一个事件的触发就导致了另一个模块中的过程调用。

从架构上说，这种风格的构件是一些模块，这些模块既可以是一些过程，又可以是一些事件的集合。过程可以通用的方式调用，也可以在系统事件中注册一些过程，当发生这些事件时，过程被调用。



## 四、软件架构复用

### 1 软件架构复用的定义及分类





## 五、特定领域软件体系结构